[{"categories":["C/C++"],"content":"题目描述 引用 事情，是这样的。 有这么一天双休日的中午。 我刚把我衣服扔进了洗衣机，然后拿了个小板凳坐在旁边发呆。 然后突然想到这么无聊干脆玩会阴阳师好了，于是从斗篷帽子里掏出我的手机登录了阴阳师。 看着更新公告里写着的新SSR式神一目连感叹了一下：我要是能有个一目连该多好啊 看了一眼我家帅气的扛把子咕咕，正准备肝困难的时候发现庭院里那一串灯笼里的调查问卷有蝴蝶在绕，于是点进去填了一波在最结尾写上了我当时的愿望：我想要一目连。 然后奖励了一个符，顺手就抽了。本来以为又是R卡，没想到手机震动了一下。 握草！！！一目连！！！！ 当时我就激动的站了起来使劲看了一眼然后仰天大笑以及截图装逼。 问题 SSR全称为superior super rare，特级超稀有。一般为卡牌类游戏最高稀有等级。 题目是给出三个字符，求其升级到SSR所需要的次数。 最小为AAA，最大为SSR； SSQ升级到SSR需要升级1次， SRR升级到SSR需要升级19次。 ","date":"2021-05-19","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/:1:0","tags":["acm","C/C++","动态规划"],"title":"SSR","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/"},{"categories":["C/C++"],"content":"输入 第一行输入一个整数T（代表T组数据） 接下来T行，包含3个连续的大写字母（A~S） ","date":"2021-05-19","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/:2:0","tags":["acm","C/C++","动态规划"],"title":"SSR","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/"},{"categories":["C/C++"],"content":"输出 每个样例输出一行 升级到SSR所需的次数 ","date":"2021-05-19","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/:3:0","tags":["acm","C/C++","动态规划"],"title":"SSR","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/"},{"categories":["C/C++"],"content":"样例输入 3 SSR SRR AAA ","date":"2021-05-19","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/:4:0","tags":["acm","C/C++","动态规划"],"title":"SSR","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/"},{"categories":["C/C++"],"content":"样例输出 0 19 6857 提示 SRR升级到SSR的过程： SRR -\u003e SRS -\u003e SSA -\u003eSSB -\u003e SSC -\u003e ……-\u003eSSR 共19次 解法 本质上可看做19进制换算 ","date":"2021-05-19","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/:5:0","tags":["acm","C/C++","动态规划"],"title":"SSR","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/"},{"categories":["C/C++"],"content":"题解 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003ccstring\u003eusing namespace std; int change(char n){ switch(n){ case 'A':return 0; case 'B':return 1; case 'C':return 2; case 'D':return 3; case 'E':return 4; case 'F':return 5; case 'G':return 6; case 'H':return 7; case 'I':return 8; case 'J':return 9; case 'K':return 10; case 'L':return 11; case 'M':return 12; case 'N':return 13; case 'O':return 14; case 'P':return 15; case 'Q':return 16; case 'R':return 17; case 'S':return 18; default :return -1; } } double power(double x, int n) { double val = 1.0; while (n--) val *= x; return val; } int main() { int num; cin\u003e\u003enum; while(num--){ char a,b,c; cin\u003e\u003ea\u003e\u003eb\u003e\u003ec; int t; t=change(a)*power(19,2)+change(b)*power(19,1)+change(c)*power(19,0); cout\u003c\u003c6857-t\u003c\u003cendl; } return 0; } ","date":"2021-05-19","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/:6:0","tags":["acm","C/C++","动态规划"],"title":"SSR","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/740/"},{"categories":["C/C++"],"content":"题目 设计一个类complex，对复数进行输出。其中有两个数据成员realPart和imagePart分别表示复数的实部和虚部；提供一个成员函数set，为类数据成员赋值；提供一个成员函数print，将该类对象以realPart+imagePart*i的方式输出。 #include\u003ciostream\u003e using namespace std; class Complex { private: int realPart; int imagePart; public: void Set(int realPart, int imagePart); void Print(); }; void Complex::Set(int a, int b){ realPart = a; imagePart = b; } void Complex::Print() { cout \u003c\u003c realPart \u003c\u003c \"+\" \u003c\u003c imagePart \u003c\u003c \"*i\" \u003c\u003c endl; } int main() { Complex Number; int x, y; cin \u003e\u003e x \u003e\u003e y; Number.Set(x, y); Number.Print(); return 0; }    ","date":"2021-04-13","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/754/:0:0","tags":["C/C++","编程","面向对象"],"title":"C++面向对象：入门","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/754/"},{"categories":["C/C++"],"content":"题目描述 试计算在区间 11 到 nn的所有整数中，数字x(0 ≤ x ≤ 9)共出现了多少次？例如，在 1到11中，即在 1,2,3,4,5,6,7,8,9,10,11 中，数字 1 出现了 4 次。 输入格式 2个整数n,x，之间用一个空格隔开。 输出格式 1个整数，表示x出现的次数。 输入输出样例 输入 #1复制11 1 输出 #1复制4 说明/提示 对于 1%的数据，1≤ n ≤ 1,000,000 0 ≤ x ≤ 9   #include\u003cbits/stdc++.h\u003e using namespace std; int num(int n,int x){ int z=0; if (n \u003c 10) { if (n == x)z+=1; else z+=0; } else if (n \u003c 100) { if (n / 10 == x)z += 1; if (n % 10 == x)z += 1; else z += 0; } else if (n \u003c 1000) { if (n / 100 == x)z += 1; if (n % 10 == x)z += 1; if (n / 10 % 10 == x)z += 1; else z += 0; } else if (n \u003c 10000) { if (n / 1000 == x)z += 1; if (n % 10 == x)z += 1; if (n / 10 % 10 == x)z += 1; if (n / 100 % 10 == x)z += 1; else z += 0; } else if (n \u003c 100000) { if (n / 10000 == x)z += 1; if (n % 10 == x)z += 1; if (n / 10 % 10 == x)z += 1; if (n / 100 % 10 == x)z += 1; if (n / 1000 % 10 == x)z += 1; else z += 0; } else if (n \u003c 1000000) { if (n / 100000 == x)z += 1; if (n % 10 == x)z += 1; if (n / 10 % 10 == x)z += 1; if (n / 100 % 10 == x)z += 1; if (n / 1000 % 10 == x)z += 1; if (n / 10000 % 10 == x)z += 1; else z += 0; } else if (n \u003c 10000000) { if (n / 1000000 == x)z += 1; if (n % 10 == x)z += 1; if (n / 10 % 10 == x)z += 1; if (n / 100 % 10 == x)z += 1; if (n / 1000 % 10 == x)z += 1; if (n / 10000 % 10 == x)z += 1; if (n / 100000 % 10 == x)z += 1; else z += 0; } return z; } int main() { int n,x,i=0; cin \u003e\u003e n \u003e\u003e x; for (int j = 1; j \u003c= n; j++) { i += num(j, x); } cout \u003c\u003c i; }  ","date":"2021-04-01","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/748/:0:0","tags":["acm","C/C++","编程"],"title":"计数问题[NOIP2013普及组]","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/748/"},{"categories":["C/C++"],"content":"题目描述 为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 nn 张地毯，编号从 11 到 nn。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。 地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 输入格式 输入共 n + 2n+2 行。 第一行，一个整数 nn，表示总共有 nn 张地毯。 接下来的 nn 行中，第 i+1i+1 行表示编号 ii 的地毯的信息，包含四个整数 a ,b ,g ,ka,b,g,k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下角的坐标 (a, b)(a,b) 以及地毯在 xx 轴和 yy 轴方向的长度。 第 n + 2n+2 行包含两个整数 xx 和 yy，表示所求的地面的点的坐标 (x, y)(x,y)。 输出格式 输出共 11 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出 -1。 输入输出样例 输入 #13 1 0 2 3 0 2 3 3 2 1 3 3 2 2 输出 #13 输入 #23 1 0 2 3 0 2 3 3 2 1 3 3 4 5 输出 #2-1 说明/提示 【样例解释 1】 如下图，11 号地毯用实线表示，22 号地毯用虚线表示，33 号用双实线表示，覆盖点 (2,2)(2,2) 的最上面一张地毯是 33 号地毯。 【数据范围】 对于 30%3% 的数据，有 n \\le 2n≤2。 对于 50%5% 的数据，0 \\le a, b, g, k \\le 100≤a,b,g,k≤1。 对于 100%1% 的数据，有 0 \\le n \\le 10^4≤n≤14, 0 \\le a, b, g, k \\le {10}^5≤a,b,g,k≤105。 #include\u003cbits/stdc++.h\u003e using namespace std; struct tanzi { int a, b, g, k; }; int main() { int n; cin \u003e\u003e n; int i,x,y; tanzi m[10001]; for (i = 1; i \u003c= n; i++) { cin \u003e\u003e m[i].a \u003e\u003e m[i].b \u003e\u003e m[i].g \u003e\u003e m[i].k; } cin \u003e\u003e x \u003e\u003e y; for (i = n; i \u003e0; i--) { if (x \u003e= m[i].a \u0026\u0026 x \u003c= m[i].a + m[i].g \u0026\u0026 y \u003e= m[i].b \u0026\u0026 y \u003c= m[i].b + m[i].k) { cout \u003c\u003c i; break; } } if (i == 0)cout \u003c\u003c \"-1\"; }  noip2011 提高组 day1 第 11 题。 ","date":"2021-03-17","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/739/:0:0","tags":["acm","C/C++","搜索"],"title":"铺地毯[NOIP2011提高组]","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/739/"},{"categories":["随笔"],"content":" 摘编自CSDN ","date":"2021-03-16","objectID":"/2021/%E9%9A%8F%E7%AC%94/735/:0:0","tags":null,"title":"常用端口总结","uri":"/2021/%E9%9A%8F%E7%AC%94/735/"},{"categories":["随笔"],"content":"/***\\*简易版**********/ 21端口ftp：21端口主要用于ftp（file transfer protocol，文件传输协议）服务。 23端口telnet：23端口主要用于telnet（远程登录）服务，是internet上普遍采用的登录和仿真程序。 25端口：25端口为smtp（simple mail transfer protocol，简单邮件传输协议）服务器所开放，主要用于发送邮件，如今绝大多数邮件服务器都使用该协议。 53端口：53端口为dns（domain name server，域名服务器）服务器所开放，主要用于域名解析，dns服务在nt系统中使用的最为广泛。 67、68端口：67、68端口分别是为bootp服务的bootstrap protocol server（引导程序协议服务端）和bootstrap protocol client（引导程序协议客户端）开放的端口。 69端口：tftp是cisco公司开发的一个简单文件传输协议，类似于ftp。 79端口：79端口是为finger服务开放的，主要用于查询远程主机在线用户、操作系统类型以及是否缓冲区溢出等用户的详细信息。 80端口：80端口是为http（hypertext transport protocol，超文本传输协议）开放的，这是上网冲浪使用最多的协议，主要用于在www（world wide web，万维网）服务上传输信息的协议。 99端口：99端口是用于一个名为“metagram relay”（亚对策延时）的服务，该服务比较少见，一般是用不到的。 109、110端口：109端口是为pop2（post office protocol version 2，邮局协议2）服务开放的，110端口是为pop3（邮件协议3）服务开放的，pop2、pop3都是主要用于接收邮件的。 111端口：111端口是sun公司的rpc（remote procedure call，远程过程调用）服务所开放的端口，主要用于分布式系统中不同计算机的内部进程通信，rpc在多种网络服务中都是很重要的组件。 113端口：113端口主要用于windows的“authentication service”（验证服务）。 119端口：119端口是为“network news transfer protocol”（网络新闻组传输协议，简称nntp）开放的。 135端口：135端口主要用于使用rpc（remote procedure call，远程过程调用）协议并提供dcom（分布式组件对象模型）服务。 137端口：137端口主要用于“netbios name service”（netbios名称服务）。 139端口：139端口是为“netbios session service”提供的，主要用于提供windows文件和打印机共享以及unix中的samba服务。 143端口：143端口主要是用于“internet message access protocol”v2（internet消息访问协议，简称imap）。 161端口：161端口是用于“simple network management protocol”（简单网络管理协议，简称snmp）。 443端口：43端口即网页浏览端口，主要是用于https服务，是提供加密和通过安全端口传输的另一种http。 554端口：554端口默认情况下用于“real time streaming protocol”（实时流协议，简称rtsp）。 1024端口：1024端口一般不固定分配给某个服务，在英文中的解释是“reserved”（保留）。 1080端口：1080端口是socks代理服务使用的端口，大家平时上网使用的www服务使用的是http协议的代理服务。 1755端口：1755端口默认情况下用于“microsoft media server”（微软媒体服务器，简称mms）。 4000端口：4000端口是用于大家经常使用的 聊天工具的，再细说就是为 客户端开放的端口， 服务端使用的端口是8000。 5554端口：在今年4月30日就报道出现了一种针对微软lsass服务的新蠕虫病毒——震荡波（worm.sasser），该病毒可以利用tcp 5554端口开启一个ftp服务，主要被用于病毒的传播。 5632端口：5632端口是被大家所熟悉的远程控制软件pcanywhere所开启的端口。 8080端口：8080端口同80端口，是被用于www代理服务的，可以实现网页端口概念 在网络技术中，端口（port）大致有两种意思：一是物理意义上的端口，比如，adsl modem、集线器、交换机、路由器用于连接其他网络设备的接口，如rj-45端口、sc端口等等。二是逻辑意义上的端口，一般是指tcp/ip协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于ftp服务的21端口等等。 们这里将要介绍的就是逻辑意义上的端口。 ","date":"2021-03-16","objectID":"/2021/%E9%9A%8F%E7%AC%94/735/:0:1","tags":null,"title":"常用端口总结","uri":"/2021/%E9%9A%8F%E7%AC%94/735/"},{"categories":["随笔"],"content":"/***\\*完整版端口**********/ tcpmux 1/tcp # TCP port service multiplexer tcpmux 1/udp # TCP port service multiplexer rje 5/tcp # Remote Job Entry rje 5/udp # Remote Job Entry echo 7/tcp echo 7/udp discard 9/tcp sink null discard 9/udp sink null systat 11/tcp users systat 11/udp users daytime 13/tcp daytime 13/udp qotd 17/tcp quote qotd 17/udp quote msp 18/tcp # message send protocol msp 18/udp # message send protocol chargen 19/tcp ttytst source chargen 19/udp ttytst source ftp-data 20/tcp ftp-data 20/udp ftp 21/tcp ftp 21/udp fsp fspd ssh 22/tcp # The Secure Shell (SSH) Protocol ssh 22/udp # The Secure Shell (SSH) Protocol telnet 23/tcp telnet 23/udp lmtp 24/tcp # LMTP Mail Delivery lmtp 24/udp # LMTP Mail Delivery smtp 25/tcp mail smtp 25/udp mail time 37/tcp timserver time 37/udp timserver rlp 39/tcp resource # resource location rlp 39/udp resource # resource location nameserver 42/tcp name # IEN 116 nameserver 42/udp name # IEN 116 nicname 43/tcp whois nicname 43/udp whois tacacs 49/tcp # Login Host Protocol (TACACS) tacacs 49/udp # Login Host Protocol (TACACS) re-mail-ck 50/tcp # Remote Mail Checking Protocol re-mail-ck 50/udp # Remote Mail Checking Protocol domain 53/tcp # name-domain server domain 53/udp whois++ 63/tcp whois++ 63/udp bootps 67/tcp # BOOTP server bootps 67/udp bootpc 68/tcp dhcpc # BOOTP client bootpc 68/udp dhcpc tftp 69/tcp tftp 69/udp gopher 70/tcp # Internet Gopher gopher 70/udp netrjs-1 71/tcp # Remote Job Service netrjs-1 71/udp # Remote Job Service netrjs-2 72/tcp # Remote Job Service netrjs-2 72/udp # Remote Job Service netrjs-3 73/tcp # Remote Job Service netrjs-3 73/udp # Remote Job Service netrjs-4 74/tcp # Remote Job Service netrjs-4 74/udp # Remote Job Service finger 79/tcp finger 79/udp http 80/tcp www www-http # WorldWideWeb HTTP http 80/udp www www-http # HyperText Transfer Protocol http 80/sctp # HyperText Transfer Protocol kerberos 88/tcp kerberos5 krb5 # Kerberos v5 kerberos 88/udp kerberos5 krb5 # Kerberos v5 supdup 95/tcp supdup 95/udp hostname 101/tcp hostnames # usually from sri-nic hostname 101/udp hostnames # usually from sri-nic iso-tsap 102/tcp tsap # part of ISODE. csnet-ns 105/tcp cso # also used by CSO name server csnet-ns 105/udp cso rtelnet 107/tcp # Remote Telnet rtelnet 107/udp pop2 109/tcp pop-2 postoffice # POP version 2 pop2 109/udp pop-2 pop3 110/tcp pop-3 # POP version 3 pop3 110/udp pop-3 sunrpc 111/tcp portmapper rpcbind # RPC 4.0 portmapper TCP sunrpc 111/udp portmapper rpcbind # RPC 4.0 portmapper UDP auth 113/tcp authentication tap ident auth 113/udp authentication tap ident sftp 115/tcp sftp 115/udp uucp-path 117/tcp uucp-path 117/udp nntp 119/tcp readnews untp # USENET News Transfer Protocol nntp 119/udp readnews untp # USENET News Transfer Protocol ntp 123/tcp ntp 123/udp # Network Time Protocol netbios-ns 137/tcp # NETBIOS Name Service netbios-ns 137/udp netbios-dgm 138/tcp # NETBIOS Datagram Service netbios-dgm 138/udp netbios-ssn 139/tcp # NETBIOS session service netbios-ssn 139/udp imap 143/tcp imap2 # Interim Mail Access Proto v2 imap 143/udp imap2 snmp 161/tcp # Simple Net Mgmt Proto snmp 161/udp # Simple Net Mgmt Proto snmptrap 162/tcp # SNMPTRAP snmptrap 162/udp snmp-trap # Traps for SNMP cmip-man 163/tcp # ISO mgmt over IP (CMOT) cmip-man 163/udp cmip-agent 164/tcp cmip-agent 164/udp mailq 174/tcp # MAILQ mailq 174/udp # MAILQ xdmcp 177/tcp # X Display Mgr. Control Proto xdmcp 177/udp nextstep 178/tcp NeXTStep NextStep # NeXTStep window nextstep 178/udp NeXTStep NextStep # server bgp 179/tcp # Border Gateway Proto. bgp 179/udp bgp 179/sctp prospero 191/tcp # Cliff Neuman’s Prospero prospero 191/udp irc 194/tcp # Internet Relay Chat irc 194/udp smux 199/tcp # SNMP Unix Multiplexer smux 199/udp at-rtmp 201/tcp # AppleTalk routing at-rtmp 201/udp at-nbp 202/tcp # AppleTalk name binding at-nbp 202/udp at-echo 204/tcp # AppleTalk echo at-echo 204/udp at-zis 206/tcp # AppleTalk zone information at-zis 206/udp qmtp 209/tcp # Quick Mail Transfer Protocol qmtp 209","date":"2021-03-16","objectID":"/2021/%E9%9A%8F%E7%AC%94/735/:0:2","tags":null,"title":"常用端口总结","uri":"/2021/%E9%9A%8F%E7%AC%94/735/"},{"categories":["C/C++"],"content":"题目描述 陶陶家的院子里有一棵苹果树，每到秋天树上就会结出 101 个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个 303 厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。 现在已知 101 个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。 输入格式 输入包括两行数据。第一行包含 101 个 1001 到 2002 之间（包括 1001 和 2002 ）的整数（以厘米为单位）分别表示 101 个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个 1001 到 12012 之间（包含 1001 和 12012 ）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。 输出格式 输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。 #include\u003cbits/stdc++.h\u003e using namespace std; int a[15]; int main() { int b, B, A, c = 0; for (int i = 1; i \u003c= 10; i++)cin \u003e\u003e a[i]; cin \u003e\u003e b; B = b + 30; for (int i = 1; i \u003c= 10; i++)if (a[i] \u003c= B)c++; cout \u003c\u003c c; return 0; }  ","date":"2021-03-14","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/730/:0:0","tags":["C/C++"],"title":"陶陶摘苹果[NOIP2005]","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/730/"},{"categories":["未分类"],"content":" 转载自zu1k–IPFS新手指北 IPFS新手指北 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:0:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"IPFS简介 IPFS全称InterPlanetary File System，中文名叫星际文件系统，听起来非常酷炫。 它是是一个旨在创建持久且分布式存储和共享文件的网络传输协议，是一种内容可寻址的对等超媒体分发协议。在IPFS网络中的全球所有节点将构成一个分布式文件系统，全球中的每一个人都可以通过IPFS网关存储和访问IPFS里面的文件。 这个酷炫的项目最初由Juan Benet设计，自2014年开始由Protocol Labs在开源社区的帮助下发展，是一个完全开源的项目。 IPFS官网{.broken_link} GitHub ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:1:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"IPFS的优点 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:2:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"与现有Web比较 现有的网络技术效率低下、成本高昂 HTTP一次从一台计算机下载文件，而不是同时从多台计算机获取文件。点对点IPFS节省了大量的带宽，视频高达60%，这使得无需重复地高效地分发大量数据成为可能。 现有的网络无法保存人类的历史 一个网页的平均寿命是100天，然后就永远消失了。我们这个时代的主要媒介还不够脆弱。IPFS保留文件的每一个版本，并使为镜像数据建立弹性网络变得简单。 现有的网络是集中的，限制了机会 互联网作为人类历史上最伟大的均衡器之一，推动了创新的发展，但日益巩固的集权控制威胁着这一进步。IPFS通过分布式技术来避免这一点。 现有的网络深度依赖主干网 IPFS支持创建多样化的弹性网络，以实现持久可用性，无论是否有Internet主干网连接。这意味着发展中国家在自然灾害期间，或者在咖啡厅的wi-fi上时，能够更好地连接。 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:2:1","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"IPFS做的更好 IPFS宣称，无论你现在在用已有的Web技术干什么，IPFS都可以做到更好。 对于归档人员 IPFS提供了数据块去重、高性能和基于集群的数据持久化，这有利于存储世界上的信息来造福后代 对于服务提供商 IPFS提供安全的P2P内容交付，可以为服务提供者节省数百万带宽成本 对于研究者 如果您使用或分发大型数据集，IPFS可以帮助您提供快速的性能和分散的归档 对于世界发展 对于那些互联网基础设施较差的人来说，高延迟网络是一大障碍。IPFS提供对数据的弹性访问，独立于延迟或主干网连接 对于区块链 使用IPFS，您可以处理大量数据，并在事务中放置不可变的永久链接—时间戳和保护内容，而不必将数据本身放在链上 对于内容创造者 IPFS充分体现了网络的自由和独立精神，可以帮助您以更低的成本交付内容 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:2:2","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"工作原理 让我们通过向IPFS添加一个文件这个过程，来简单看一下IPFS是如何工作的 IPFS将文件切割为多个小块，每个块的大小为256KB，块的数量由文件的大小决定。然后计算每个块的Hash，作为这个块的指纹。 因为很多文件数据有重复的部分，在切割成小块后，这些小块有的会完全相同，表现出来就是指纹Hash相同。拥有相同指纹Hash的块被视为同一个块，所以相同的数据在IPFS都表现为同一块，这也就消除了存储相同数据的额外开销。 IPFS网络中的每一个节点只存储自己感兴趣的内容，也就是该IPFS节点的使用者经常访问、或指定要固定的内容。 除此之外还需要额外存储一些索引信息，这些索引信息用来帮助文件查找的寻址工作。当我们需要获取某个块的时候，索引信息就可以告诉IPFS这个特定块在哪些节点上有存储。 当我们要从IPFS中查看或者下载某个文件时，IPFS便要通过改文件的指纹Hash查询索引信息，并向自己连接的节点进行询问。这一步需要找到IPFS网络中的哪些节点存储着自己想要的文件数据块。 如果你无法记住IPFS中存储的文件的指纹Hash(是一段非常长的字符串)，实际上你也无须记住这个Hash，IPFS提供了IPNS来提供人类可读名字到指纹Hash之间的映射，你只需要记住你添加在IPNS中的人类可读名字即可。 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:3:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"基本使用 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:4:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"安装 设置环境变量IPFS_PATH，这个目录在后面进行初始化和使用的时候会作为IPFS的本地仓库。如果这里不进行设置，IPFS默认会使用用户目录下的.ipfs文件夹作为本地仓库。 初始化 运行命令 `ipfs init` 进行初始化，这一步会初始化密钥对，并在刚刚指定的IPFS_PATH目录创建初始文件。 查看节点ID信息 运行命令 `ipfs id` 即可查看自己IPFS节点ID信息，包含了节点ID、公钥、地址、代理版本、协议版本、支持的协议等信息 可以通过 ipfs id 别人的ID来查看别人的节点ID信息 检查可用性 通过显示的命令来检查可用性，这里使用ipfs cat命令来查看指定的CID对应的内容。 开启守护进程 运行下面命令开启守护进程 “`powershell ipfs daemon “` ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:4:1","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"获取文件(夹) IPFS获取文件的方式是隐式的，我们可以通过查看、下载等命令，告诉IPFS你要去获取我想要的文件 查看文本 查看文本使用 ipfs cat命令来进行，就如前面检查可用性的使用一样 下载二进制 对于图片、视频等文件，无法使用cat命令来查看（cat出来是一堆乱码），此时我们可以使用ipfs get cid的方式来将文件下载到本地。不过这样直接下载文件名会是指定的CID，一个长字符串不具有识别性，我们可以重定向到指定的文件，ipfs get cid -o newname.png 列出目录 通过ipfs ls命令来列出一个目录 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:4:2","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"添加文件(夹) 通过ipfs add 文件名命令来将文件添加到IPFS 如果需要添加文件夹，需要添加-r参数来使其递归处理 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:4:3","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"相关概念 在进行深一步学习之前，先让我们来看一下关于IPFS几个不得不知道的概念，这些概念是IPFS的基础组成部分，对后续的使用至关重要 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:5:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"Peer Peer是对等节点，因为IPFS是基于P2P技术实现的，所以没有服务器客户端这一说，每个人都同时是服务器和客户端，人人为我，我为人人。 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:5:1","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"CID 内容标识符（CID）是一个用于指向IPFS中的内容的标签。它不指示内容存储在哪里，但它根据内容数据本身形成一种地址。无论它指向的内容有多大，CID都很短 详细内容见：IPFS官方文档：Content addressing and CIDs{.broken_link} 在线的CID查看器：CID Inspector{.broken_link} ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:5:2","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"Gateway IPFS官方提供的Gateway: https://ipfs.io/ Cloudflare提供的IPFS Gateway服务：https://cf-ipfs.com 其他公开的Gateway列表：https://ipfs.github.io/public-gateway-checker/ https://www.cloudflare.com/distributed-web-gateway/ 具体见：IPFS文档：Gateway{.broken_link} ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:5:3","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"IPNS IPFS使用基于内容的寻址方式，简单说就是IPFS根据文件数据的Hash来生成CID，这个CID只与文件内容有关，这也就导致了如果我们修改这个文件的内容，这个CID也会改变。如果我们通过IPFS给别人分享文件，则每次更新内容时都需要给此人一个新链接。 为了解决这个问题，星际名称系统（IPNS）通过创建一个可以更新的地址来解决这个问题。 具体见：IPFS文档：IPNS{.broken_link} ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:5:4","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"IPLD https://docs.ipfs.io/concepts/ipld/ ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:5:5","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"在IPFS部署网站 既然IPFS宣称能够构建新一代分布式Web，那我们便想要把自己的网站部署到IPFS上去，一起体验一下去中心化、分布式的Web3.0技术 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:6:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"将文件添加到IPFS中 我使用的是Hugo静态网站生成器生成我的博客，生成的内容存放在public目录下，所以首先我需要将public目录及其里面的所有内容添加到IPFS中。 “`powershell # -r 参数代表递归添加 ipfs add -r public # 实际运行效果 PS D:\\blog\u003e ipfs add -r public added QmZT5jXEi2HFVv8tzuDqULBaiEPc8geZFVjXxb9iAsBqbg public/404.html added QmcGDfkg6mcboba3MkNeamGQvRgdnHiD4HZhvCRwEnSdSj public/CNAME 很长的滚屏后…… added QmT61SS4ykbnt1ECQFDfX27QJdyhsVfRrLJztDvbcR7Kc1 public/tags added QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj public 35.12 MiB / 35.12 MiB [===========================================] 100.00% “` 如果你不想看这么长的滚屏，只想要最后一个Hash，可以添加一个 `Q` （quiet） 参数 “`powershell PS D:\\blog\\blog\u003e ipfs add -rQ public QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj “` ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:6:1","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"通过IPFS网关访问 在刚刚添加完成的最后，名称为public的那串Hash便是public目录的CID，我们现在可以通过这个CID在IPFS网关上访问我们刚刚的添加的内容。 本机网关访问 我们先通过本机的IPFS网关来访问一下，看看有没有添加成功。注意这一步需要你本地已经开启了IPFS守护进程。 访问：http://localhost:8080/ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj{.broken_link} 然后浏览器会自动进行跳转，可以看到能够正常访问我们的页面 注意 你会发现浏览器地址栏的网址为一个另一个长字符串构成的域名 长字符串.ipfs.localhost:8080 这里的长字符串是IPFS中的另一个概念：IPLD 如果你的页面只能够显示内容，但是样式是错误的，如下图 这是因为使用的是绝对地址，我们需要使用相对地址的形式，如果你和我一样使用Hugo，那么只需要在你的配置文件中增加 `relativeURLs = true` 即可 远程网关访问 刚刚我们通过本机的IPFS网关成功访问到了IPFS中的网站，现在我们找一个公开的其他的IPFS网关来访问试一下 这里我选择IPFS官方维护的网关：https://ipfs.io，访问：https://ipfs.io/ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj 需要注意的是，此时网站还只存在于我们本机上，其他IPFS网关从IPFS网络中找到我们的网站文件需要一段时间，我们需要保证此时IPFS守护进程不关闭并已经连接了成百上千的其他节点，这样有利于IPFS官方Gateway尽快找到我们。 经过多次刷新和焦急的等待后，终于有了显示 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:6:2","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"使用IPNS进行映射 使用命令 `ipfs name publish CID` 来发布一个IPNS，这里可能需要等待一会 “`powershell PS D:\\blog\\blog\u003e ipfs name publish QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj Published to k51qzi5uqu5djhbknypxifn09wxhtf3y1bce8oriud1ojqz5r71mpu75rru520: /ipfs/QmdoJ8BiuN8H7K68hJhk8ZrkFXjU8T9Wypi9xAyAzt2zoj “` 通过使用IPNS映射，后续我们可以不断更新网站内容。如果没有使用IPNS而是直接发布CID，那别人便无法访问最新的版本了 注意 如果使用了IPNS，需要备份节点的私钥和生成IPNS地址时生成的Key 它们分别存储在你init时显示的目录下的config文件和keystore文件夹内 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:6:3","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"解析域名 IPNS不是在IPFS上创建可变地址的唯一方法，我们还可以使用DNSLink，它目前比IPNS快得多，还使用人类可读的名称。 例如我想要给刚刚发布在IPFS上的网站绑定ipfs.lgf.im这个域名，那我就需要创建_dnslink.ipfs.lgf.im的TXT记录 然后任何人都可以用 `/ipfs/ipfs.lgf.im` 来找到我的网站了，访问http://localhost:8080/ipns/ipfs.lgf.im{.broken_link} 详细文档见：IPFS文档：DNSLink{.broken_link} ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:6:4","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"更新内容 更新内容时，只需要再添加一次，然后重新发布IPNS，如果你是使用DNSLink的方式，还需要修改DNS记录 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:6:5","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"底层技术 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:7:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"Merkle有向无环图（DAG） 每个Merkle都是一个有向无环图 ，因为每个节点都通过其名称访问。每个Merkle分支都是其本地内容的哈希，它们的子节点使用它们的哈希而非完整内容来命名。因此，在创建后将不能编辑节点。这可以防止循环（假设没有哈希碰撞），因为无法将第一个创建的节点链接到最后一个节点从而创建最后一个引用。 对任何Merkle来说，要创建一个新的分支或验证现有分支，通常需要在本地内容的某些组合体（例如列表的子哈希和其他字节）上使用一种哈希算法。IPFS中有多种散列算法可用。 输入到散列算法中的数据的描述见 https://github.com/ipfs/go-ipfs/tree/master/merkledag 具体见：IPFS文档：Merkle{.broken_link} ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:7:1","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"分布式散列表DHT 具体见：IPFS文档：DHT{.broken_link} ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:7:2","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"上层应用 IPFS作为一个文件系统，本质就是用来存储文件，基于这个文件系统的一些特性，有很多上层应用涌现出来。 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:8:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"Filecone ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:9:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"基于IPFS构建应用 IPFS提供了IPFS协议的Golang和JavaScript实现，可以非常方便的将IPFS集成到我们的应用当中，充分利用IPFS的各种优势。 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:10:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"未来的期望 对于P2P：https://t.lgf.im/post/618818179793371136/%E5%85%B3%E4%BA%8Eresilio-sync ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:11:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"一些问题 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:12:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"IPFS可以永久存储文件？ 很多人误认为IPFS可以永久存储文件，从使用的技术来讲的确更有利于永久存储内容，但是还需不断需要有人访问、Pin、传播该内容，否则待全网所有节点都将该内容数据GC掉，数据还是会丢失。 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:12:1","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"IPFS是匿名的？ 有人认为P2P就是匿名的，就像Tor一样，就像以太坊一样。实际上绝大部分P2P应用都不是匿名的，IPFS也不是匿名的，所以当你在发布敏感信息的时候，需要保护好自己。IPFS目前还不支持Tor网络。 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:12:2","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"IPFS速度块，延迟低？ 从理论上来讲，只要节点数量足够多，基于P2P技术的IPFS速度能够跑满你的带宽，延迟也有可能比中心化的Web低。但实际上，就目前情况而言，使用IPFS的人并不多，你链接的IPFS节点最多也就1000个左右（至少目前阶段我最多也就撑死连1000个以内），所以并不能达到理论的理想状态，所以现在IPFS的速度并不是很快，并且很少人访问的冷数据延迟很高，还有大概率找不到。 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:12:3","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"IPFS是骗局，Filecone是骗局？ 的确，目前有很多投机的人，他们想要通过销售所谓的IPFS矿机（其实就是普通的电脑接上大硬盘）来盈利，所以他们故意去混淆IPFS、Filecone、比特币、区块链等概念，打着永久存储的伪概念，用区块链这个热点来欺骗啥都不懂的老人，这种行为非常无耻。 实际上，IPFS本身并不是骗局，基于IPFS产生的激励层Filecone也不是骗局，从我的使用来看，任何人都无需特意去购买任何所谓的IPFS矿机，只需要在自己的电脑运行时，后台跑一个IPFS守护进程就可以了。不要被所谓的币冲昏了头脑。 ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:12:4","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"参考资料 IPFS官网{.broken_link} IPFS文档{.broken_link} IPFS博客{.broken_link} 维基百科：星际文件系统{.broken_link} 将博客部署到星际文件系统（IPFS） ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:13:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["未分类"],"content":"资源分享 机械工业出版社294G原版PDF：/ipfs/QmZYDnPgTRs1MmBx9TPrADFV1K85sPSqLJhAShWayubu9c{.broken_link} ","date":"2021-01-30","objectID":"/2021/uncategorized/696/:14:0","tags":["ipfs"],"title":"IPFS新手指北","uri":"/2021/uncategorized/696/"},{"categories":["C/C++"],"content":"题目描述 给定区间[L,R]\"[L,R] ， 请计算区间中素数的个数。 其中2≤L≤R≤2×109\"2≤L≤R≤2×109，R−L≤1000000\"R−L≤1000000 输入 两个数L\"L和R\"R。 输出 一行，区间中素数的个数。 #include\u003cbits/stdc++.h\u003e using namespace std; #define maxn 1000010 int pri[10000]; typedef long long LL; bool a[maxn]; int Eratosthenes_Sieve(int n, int pri[]) { for (int i = 2; i * i \u003c= n; i++) if (a[i] == 0) for (int j = i \u003c\u003c 1; j \u003c= n; j += i) a[j] = 1; int cnt = 0; for (int i = 2; i \u003c= n; i++) if (!a[i]) pri[cnt++] = i; return cnt; } int main() { int cnt = Eratosthenes_Sieve(50000, pri); LL L, R; scanf(\"%lld %lld\", \u0026L, \u0026R); memset(a, 0, sizeof(a)); for (int i = 0; i \u003c cnt; i++) for (LL j = max(2ll, (L - 1) / pri[i] + 1) * pri[i]; j \u003c= R; j += pri[i]) a[j - L] = 1; int ans = 0; for (LL i = L; i \u003c= R; i++) if (a[i - L] == 0) ans++; printf(\"%d\", ans); return 0; }  ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/663/:0:0","tags":["acm","C/C++","数论","编程"],"title":"区间质数统计（加强版）","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/663/"},{"categories":["C/C++"],"content":"题目描述 盖伦是个小学一年级的学生，在一次数学课的时候，老师给他们出了一个难题： 老师给了一个正整数 n，需要在不大于n的范围内选择三个正整数(可以是相同的)，使它们三个的最小公倍数尽可能的大。盖伦很想第一个解决这个问题，你能帮助盖伦拿到“first blood”吗？ 输入 首先是一个正整数T，表示有T组测试数据 每组测试数据是一个正整数n(1输出 对于每组测试数据，输出最大的最小公倍数，每个输出单独占一行 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a; cin \u003e\u003e a; long long n; while (a--) { cin \u003e\u003e n; if (n \u003e= 1 \u0026\u0026 n \u003c= 2) { cout \u003c\u003c n \u003c\u003c endl; continue; } cout \u003c\u003c (n % 2 ? n * (n - 1) * (n - 2) : n % 3 ? n * (n - 1) * (n - 3) : (n - 1) * (n - 2) * (n - 3)) \u003c\u003c endl; } }   ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/661/:0:0","tags":["acm","C/C++","编程"],"title":"First Blood","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/661/"},{"categories":["C/C++"],"content":"题目描述 定义f0=0\"f=,f1=1\"f1=1 对于n\u003e=2\"n=2定义 fn=(fn−1+fn−2)mod10\"fn=(fn−1+fn−2)mod10 输入 0≤k≤1018\"≤k≤1018 输出 计算fk\"fk #include\u003cbits/stdc++.h\u003e using namespace std; int a(long long n) { int arr[60] = { 0, 1, 1, 2, 3, 5, 8, 3, 1, 4, 5, 9, 4, 3, 7, 0, 7, 7, 4, 1, 5, 6, 1, 7, 8, 5, 3, 8, 1, 9, 0, 9, 9, 8, 7, 5, 2, 7, 9, 6, 5, 1, 6, 7, 3, 0, 3, 3, 6, 9, 5, 4, 9, 3, 2, 5, 7, 2, 9, 1 }; return arr[n % 60]; } int main() { long long n; while (scanf(\"%lld\", \u0026n) != EOF) printf(\"%d\\n\", a(n)); }  ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/659/:0:0","tags":["acm","C/C++","动态规划","编程"],"title":"Easy Fibonacci","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/659/"},{"categories":["C/C++"],"content":"题目描述 输入正整数a\"a,b\"b,c\"c 其中1≤a,b\u003c106\"1≤a,b106，c≤100\"c≤100输出a/b\"a/b的小数形式，精确到小数点后的c\"c位,例如a=1\"a=1,b=6\"b=6,c=4\"c=4输出应该是0.1667\"0.1667 输入 多组输入，每行有3个正整数a\"a，b\"b，c\"c 输出 输出a/b\"a/b的小数形式，精确到小数点后的c\"c位, #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a, b, c; int temp0, temp1; while (cin \u003e\u003e a \u003e\u003e b \u003e\u003e c) { temp0 = a / b; cout \u003c\u003c temp0 \u003c\u003c \".\"; a = (a - temp0 * b) * 10; while (c--) { temp0 = a / b; if (c \u003e 0) { cout \u003c\u003c temp0; a = (a - temp0 * b) * 10; } else { a = (a - temp0 * b) * 10; temp1 = a / b; if (temp1 \u003e 5) { cout \u003c\u003c temp0 + 1 \u003c\u003c endl; } else { cout \u003c\u003c temp0 \u003c\u003c endl; } } } } }  ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/657/:0:0","tags":["acm","C/C++","编程"],"title":"分数化小数","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/657/"},{"categories":["C/C++"],"content":"题目描述 对于给定的正整数N，输出N^N的最左边一位数。 输入 输入包含多组测试数据。输入的第一行是一个整数T，代表测试组数。随后输入T组测试数据，每组测试数据包含一个正整数N ( 1输出 对于每组测试数据，输出N^N次方的最左边一位数。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n, t; scanf(\"%d\", \u0026t); while (t--) { scanf(\"%d\", \u0026n); double x = n * log10((double)n); x -= (long long)x; x = (int)pow(10, x); printf(\"%.0lf\\n\", x); } }  ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/653/:0:0","tags":["acm","C/C++","编程"],"title":"最左边一位数","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/653/"},{"categories":["C/C++"],"content":"题目描述 小明被一个问题给难住了，现在需要你帮帮忙。问题是：给出两个整数，求出它们的最大公约数和最小公倍数。 特别的我们规定 如果x!=0 gcd(x,0)=gcd(0,x)=x,lcm(x,0)=lcm(0,x)=0 输入 第一行输入一个大于0的整数n(n输出 输出每组测试数据的最大公约数和最小公倍数 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a, b, d; cin \u003e\u003e d; while (d--) { cin \u003e\u003e a \u003e\u003e b; int c = __gcd(a, b); cout \u003c\u003c c \u003c\u003c \" \" \u003c\u003c a * b / c \u003c\u003c endl; } }  ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/651/:0:0","tags":["acm","C/C++","编程"],"title":"公约数和公倍数","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/651/"},{"categories":["C/C++"],"content":"题目描述 a\"a除以m\"m的余数称为a\"a对于m\"m的模，一般记做 amodb\"amodb。求apmodm\"apmodm。 输入 输入数据中含有一些数据组，每个数据组占一行，包括a\"a、p\"p、m\"m（1≤a\"1≤a1≤a,p≤231−1\"p≤231−1,1≤m≤216\"1≤m≤216）三个整数，若三个数都为0\"，则表示输入结束。 输出 针对每组数据，输出apmodm\"apmodm。，每个结果占一行。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; int main() { ll a, b, c; while (scanf(\"%lld%lld%lld\", \u0026a, \u0026b, \u0026c)) { ll d = 1; if (a == 0 \u0026\u0026 b == 0 \u0026\u0026 c == 0)break; for (int i = 0; i \u003c b; i++)d = d * a % c; printf(\"%lld\\n\", d); } }  ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/648/:0:0","tags":["acm","C/C++","编程"],"title":"整数模","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/648/"},{"categories":["C/C++"],"content":"题目描述 一个整数n\"n的阶乘可以写成n!\"n!，它表示从1\"11到n\"nn这n\"nn个整数的乘积。阶乘的增长速度非常快，例如，13!\"13!就已经比较大了，已经无法存放在一个整型变量 中；而35!\"35!就更大了，它已经无法存放在一个浮点型变量中。因此，当n\"n比较大时，去计算n!\"n!n!是非常困难的。幸运的是，在本题中，我们的任务不是去计算 n!\"n!，而是去计算n!\"n!最右边的那个非0\"的数字是多少。例如，5!=1∗2∗3∗4∗5=120\"5!=1∗2∗3∗4∗5=120，因此5!\"5!最右边的那个非0\"的数字是2\"2。再如：7!=5040\"7!=5040，因此7!\"7!最右边的那个非0\"的数字是4\"4。请编写一个程序，输入一个整数n\"n(n≤100\"n≤100)，然后输出n!\"n! 最右边的那个非0\"的数字是多少。 输入 输入格式：输入只有一个整数n\"n。 输出 输出格式：输出只有一个整数，即n!\"n!最右边的那个非0\"的数字。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int arr1[10] = { 1,2,6,4,2,2,4,2,8,8 }, arr2[20] = { 8,6,8,2,8,8,6,8,2,4, 4,8,4,6,4,4,8,4,6,8 }; int n; cin \u003e\u003e n; if (n \u003c= 10)cout \u003c\u003c arr1[n - 1]; else cout \u003c\u003c arr2[((n - 10) - 1) % 20]; }   ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/646/:0:0","tags":["acm","C/C++","数论","编程"],"title":"阶乘最右边的那个非0数","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/646/"},{"categories":["未分类"],"content":"题目描述 著名的哥德巴赫猜想可以陈述为：任何一个不小于6的偶数一定可以拆成两个质数的和。如6=3+3,8=5+3等，你的任务是将一个大于6的偶数n拆成两个最接近的质数p,q,满足p+q=n. 输入 输入包含多组测试数据。每组数据包含1个偶数n（n在6到1000000之间包含边界）。 输出 对于每组测试数据，输出两个质数p,q(p#include\u003cbits/stdc++.h\u003e using namespace std; int P[1000000] = { 0 }; void Prime_list() { P[0] = P[1] = 1; for (int i = 2; i \u003c 1000000; i++) { for (int j = i * 2; j \u003c 1000000; j += i) { P[j] = 1; } } } int main() { int n; int i, cache; Prime_list(); while (cin \u003e\u003e n) { for (i = 2; i \u003c= n / 2; i++) { if (P[i] == 0 \u0026\u0026 P[n - i] == 0) { cache = i; } } cout \u003c\u003c cache \u003c\u003c \" \" \u003c\u003c n - cache \u003c\u003c endl; } }   ","date":"2021-01-09","objectID":"/2021/uncategorized/644/:0:0","tags":["acm","C/C++","动态规划","数论","编程"],"title":"哥德巴赫猜想","uri":"/2021/uncategorized/644/"},{"categories":["C/C++"],"content":"题目描述 在质数的大家庭中，大小之差不超过2的两个质数称它俩为一对孪生素数，如2和3、3和5、17和19等等。请你统计一下，在不大于自然数N的质数中，孪生素数的对数。 输入 只有一行，一个自然数N。(N输出 只有一行，一个整数，表示N以内孪生素数的对数。 #include\u003cbits/stdc++.h\u003e using namespace std; int is(int num) { for (int i = 2; i \u003c= sqrt((double)num); ++i)if (num % i == 0)return 0; return 1; } int main() { int n, count = 0, len = -1; scanf(\"%d\", \u0026n); int arr[100000] = { 0 }; for (int i = 2; i \u003c= n; ++i) { if (is(i))arr[++len] = i; } for (int i = 0; i \u003c len; ++i) { if (arr[i + 1] - arr[i] \u003c= 2) count++; } printf(\"%d\", count); }   ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/642/:0:0","tags":["acm","C/C++","动态规划","数论","编程"],"title":"孪生素数","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/642/"},{"categories":["C/C++"],"content":"题目描述 给定两个整数n\"n，m\"m, 1≤n≤220\"1≤n≤220, 1≤m≤2014\"1≤m≤2014，求 ∑i=1n(i%m)=1%m+2%m+3%m...+n%m\"∑i=1n(i%m)=1%m+2%m+3%m...+n%m 的值。 输入 第一行有一个整数N表示有N组测试数据。 每组测试数据都有两个整数n\"n，m\"m, 1≤n≤220\"1≤n≤220, 1≤m≤2014\"1≤m≤2014 输出 求出每组 ∑i=1n(i%m)=1%m+2%m+3%m...+n%m\"∑i=1n(i%m)=1%m+2%m+3%m...+n%m 的值。 #include \u003ciostream\u003e using namespace std; int main() { long long c, b, a, n, m; cin \u003e\u003e a; while (a--) { cin \u003e\u003e n \u003e\u003e m; b = n % m, c = n / m; cout \u003c\u003c m * (m - 1) / 2 * c + b * (b + 1) / 2 \u003c\u003c \"\\n\"; } }  ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/640/:0:0","tags":["acm","C/C++","编程"],"title":"n%m","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/640/"},{"categories":["C/C++"],"content":"题目描述 平方取中法(midsquare method)是产生[0，1]均匀分布随机数的方法之一，亦称冯·诺伊曼取中法，最早由冯·诺伊曼(John von Neumann，1903-1957)提出的一种产生均匀伪随机数的方法。这里我们将这个算法稍作修改，产生下一个伪随机的正整数n 不妨设置为 n （1）如果 n不足256 则+256 （2）n表示成32位二进制（高位补0,）， （3）舍去n的高16位 （4）计算 n*n表示成32位二进制（高位补0,）， （5）舍去高8位，低8位，获得一个16位二进制 这个就是下一个随机数m 输入 一个整数 n 输出 输出用这个算法产生的下一个整数 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n; cin \u003e\u003e n; if (n \u003c 256)n += 256; n \u003c\u003c= 16; n \u003e\u003e= 16; n *= n; n \u003c\u003c= 8; n \u003e\u003e= 16; cout \u003c\u003c n \u003c\u003c endl; return 0; }  ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/638/:0:0","tags":["acm","C/C++","位运算","编程"],"title":"平方取中法","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/638/"},{"categories":["C/C++"],"content":"题目描述 小L在坐尼克泰坦号去旅游的时候发生了意外，不慎掉入了大海里，现在需要擅长游泳的你去救他，可是他的身边被鲨鱼包围了，如果有空隙的话你可以趁鲨鱼不注意游过去救他，可如果鲨鱼将小L完全围住，那他就只能去见JACK了，现在请你判断你是否可以成功救出他。 输入 多组输入 第一行包含两个正整数n\"n,m\"m ,n≤50,m≤50\"n≤50,m≤50,表示大海的长度和宽度 第二行为n×m\"n×m的矩阵，其中：*表示海水，x表示鲨鱼，L\"L表示小L的位置，S\"S表示你的位置 （你只能朝上下左右四个方向移动） 输出 如果能救出小L，输出：I saved him. 否则输出：Sorry, I can’t save him. #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn=999; int n,m,flag; char a[maxn][maxn]; int X[4]={0,0,1,-1}; int Y[4]={1,-1,0,0}; bool inq[maxn][maxn]; struct node{ int x; int y; }s,g,Node; bool judge(int x,int y){ if(x\u003c0||x\u003e=n||y\u003c0||y\u003e=m)return false; if(a[x][y]=='x'||inq[x][y]==true)return false; return true; } void bfs(){ queue\u003cnode\u003eq; q.push(s); while(q.empty()!=1){ node top=q.front(); q.pop(); if(top.x==g.x\u0026\u0026top.y==g.y){ flag=1; return; } for(int i=0;i\u003c4;i++){ int newx=top.x+X[i]; int newy=top.y+Y[i]; if(judge(newx,newy)){ Node.x=newx,Node.y=newy; q.push(Node); inq[newx][newy]=true; } } } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); while(cin\u003e\u003en\u003e\u003em){ flag=0; for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ cin\u003e\u003ea[i][j]; inq[i][j]=false; } } for(int i=0;i\u003cn;i++){ for(int j=0;j\u003cm;j++){ if(a[i][j]=='S'){ s.x=i,s.y=j; }else if(a[i][j]=='L'){ g.x=i,g.y=j; } } } bfs(); if(flag==1)cout\u003c\u003c\"I saved him.\"\u003c\u003cendl; else if(flag==0)cout\u003c\u003c\"Sorry, I can't save him.\"\u003c\u003cendl; } return 0; }   ","date":"2021-01-09","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/636/:0:0","tags":["acm","C/C++","搜索","编程","递归"],"title":"海上救援","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/636/"},{"categories":["C/C++"],"content":"题目描述 给你n根火柴棍，你可以拼出多少个形如“A+B=C”的等式？等式中的A、B、C是用火柴棍拼出的整数（若该数非零，则最高位不能是0）。用火柴棍拼数字0-9的拼法如图所示： 注意： 1. 加号与等号各自需要两根火柴棍 2. 如果A≠B，则A+B=C与B+A=C视为不同的等式（A、B、C=0） 3. n根火柴棍必须全部用上 输入 只有一行，有一个整数n（n\u003c=24）。 输出 只有一行，表示能拼成的不同等式的数目。 #include\u003cbits/stdc++.h\u003e using namespace std; int g[10]={6,2,5,5,4,5,6,3,7,6}; int main() { int s=0,n,a=0,b=0,c=0; cin\u003e\u003en; for(int i=0;i\u003c=1000;i++) { for(int j=0;j\u003c1000;j++) { int k=i,p=j,m=i+j; if(k==0)a=6; else while(k\u003e0){a+=g[k%10];k=k/10;} if(p==0)b=6; else while(p\u003e0){b+=g[p%10];p=p/10;} if(m==0)c=6; else while(m\u003e0){c+=g[m%10];m=m/10;} if((a+b+c)==(n-4))s++; a=0;b=0;c=0; } } cout\u003c\u003cs; return 0; }  ","date":"2021-01-08","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/634/:0:0","tags":["acm","C/C++","搜索","编程"],"title":"火柴棒等式","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/634/"},{"categories":["C/C++"],"content":"题目描述 输入一个自然数N（1输入 输入一个自然数N（1\u003c=N\u003c=9） 输出 N的全排列，每行一个 #include \u003cbits/stdc++.h\u003e using namespace std; int n,flag[10],a[10]; void dfs(int s) { if(s==n+1) { for(int i=1;i\u003c=n;i++) printf(\"%d\",a[i]); printf(\"\\n\"); } for(int i=1;i\u003c=n;i++) { if(flag[i]==0) { a[s]=i; flag[i]=1; dfs(s+1); flag[i]=0; } } return; } int main() { scanf(\"%d\",\u0026n); dfs(1); return 0; }  ","date":"2021-01-08","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/632/:0:0","tags":["acm","C/C++","搜索","编程"],"title":"全排列","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/632/"},{"categories":["C/C++"],"content":"题目描述 现在炸弹不是想放在那里就能放在那里的了，必须由小人能够走到的地方才能放置炸弹。比如下面这个例子小人默认站在(3,3)这个位置。请问放在何处最多可以消灭多个敌人。 输入 第一行4个整数为n m x y，分别n和m表示迷宫的行和列，x和y表示小人的起始坐标（从0行0列开始计算），接下来的n行m列为地图。 1输出 最多可以消灭的敌人数。 #include\u003cbits/stdc++.h\u003e#define pi 3.14 #define mod 100 using namespace std; typedef pair\u003cint,int\u003e Node; typedef long long LL; const int Max_n=55; int n,m,sx,sy; char a[Max_n][Max_n]; int vis[Max_n][Max_n],net[4][2]={{0,1},{1,0},{0,-1},{-1,0}}; int GetSum(int i,int j){ int sum=0,x,y; x=i,y=j; while(a[x][y]!='#'){ if(a[x][y]=='G') sum++; x--; } x=i,y=j; while(a[x][y]!='#'){ if(a[x][y]=='G') sum++; x++; } x=i,y=j; while(a[x][y]!='#'){ if(a[x][y]=='G') sum++; y--; } x=i,y=j; while(a[x][y]!='#'){ if(a[x][y]=='G') sum++; y++; } return sum; } int bfs(){ memset(vis,0,sizeof(int)); queue\u0026lt;Node\u0026gt;q; q.push(Node(sx,sy)); vis[sx][sy]=1; int sum=0,mmax=0; while(q.size()){ Node node=q.front();q.pop(); sum=GetSum(node.first,node.second); if(sum\u0026gt;mmax) mmax=sum; for(int i=0;i\u0026lt;4;i++){ int nx=node.first+net[i][0]; int ny=node.second+net[i][1]; if(nx\u0026lt;0||nx\u0026gt;=n||ny\u0026lt;0||ny\u0026gt;=m) continue; if(a[nx][ny]=='.'\u0026\u0026vis[nx][ny]==0){ vis[nx][ny]=1; q.push(Node(nx,ny)); } } } return mmax; } int main(){ scanf(\"%d%d%d%d\",\u0026n,\u0026m,\u0026sx,\u0026sy); for(int i=0;i\u0026lt;n;i++) scanf(\"%s\",a[i]); int mmax=bfs(); printf(\"%d\\n\",mmax); return 0; } ","date":"2021-01-08","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/630/:0:0","tags":["acm","C/C++","搜索","编程"],"title":"再解炸弹人","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/630/"},{"categories":["C/C++"],"content":"题目描述 给你一个非负数整数n，判断n是不是一些数（这些数不允许重复使用，且为正数）的阶乘之和，如9=1！+2!+3!，如果是，则输出Yes，否则输出No； 输入 第一行有一个整数0输出 如果符合条件，输出Yes，否则输出No #include\u003cbits/stdc++.h\u003e using namespace std; int jc(int n) { int b=1; for(int i=1;i\u003c=n;i++) b*=i; return b; } int main() { int n; scanf(\"%d\",\u0026n); while(n--) { int m,b; scanf(\"%d\",\u0026m); for(int i=10;i\u003e0;i--) { if(m\u003e=jc(i)\u0026\u0026m\u003e0) m-=jc(i); if(m==0) b=1; else b=0; } if(b==1) printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0; }  ","date":"2021-01-08","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/628/:0:0","tags":["acm","C/C++","搜索","编程","贪心"],"title":"阶乘之和","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/628/"},{"categories":["C/C++"],"content":"题目描述 经典的八皇后问题，在一个8*8的棋盘上放置8个皇后，使得不能互相攻击到，皇后的攻击范围的同一行，同一列以及同一个斜线。要求输出所有不会互相攻击到的摆放方式，所有通过旋转，对称都方式得到的摆放方式均认为是不同的摆放方式。棋盘被编号为0-7行，0-7列。 输入 无输入。 输出 每行一个数字代表摆放方式，如01234567代表从第0行放在0列，第1行放在1列， 第2行放在2列，按照升序输出。 #include\u003cbits/stdc++.h\u003e using namespace std; #define max 8 int queen[max], sum=0; void show() { int i; for(i = 0; i \u003c max; i++) { printf(\"%d\", queen[i]); } printf(\"\\n\"); sum++; } int PLACE(int n) { int i; for(i = 0; i \u003c n; i++) { if(queen[i] == queen[n] || abs(queen[i] - queen[n]) == (n - i)) { return 1; } } return 0; } void NQUEENS(int n) { int i; for(i = 0; i \u003c max; i++) { queen[n] = i; if(!PLACE(n)) { if(n == max - 1) { show(); } else { NQUEENS(n + 1); } } } } int main() { NQUEENS(0); return 0; }   ","date":"2021-01-08","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/626/:0:0","tags":["acm","C/C++","编程","递归"],"title":"八皇后问题","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/626/"},{"categories":["C/C++"],"content":"题目描述 小明童鞋有一个非常精确的天平和一堆砝码，数量为n(1=输入 一个正整数n,代表砝码的个数 随后有n个整数 a0 a1 a2 …an-1 代表砝码的的重量 输出 如果可以做到输出”Of course,I can!” 不然输出””Sorry,I can’t!” #include\u003cbits/stdc++.h\u003e using namespace std; bool flag = false; void count(int array[], int i, int n, int temp, int sum) { if (i \u003e n) return; if (temp + array[i] == sum) { flag = true; return; } count(array, i + 1, n, temp + array[i], sum); count(array, i + 1, n, temp, sum); } int main() { int n; while (cin \u003e\u003e n) { int array[n]; int sum = 0; flag = false; for (int i = 0; i \u003c n; i++) { cin \u003e\u003e array[i]; sum += array[i]; } sort(array, array + n); if (sum % 2) { cout \u003c\u003c \"Sorry,I can't!\" \u003c\u003c endl; continue; } count(array, 0, n - 1, 0, sum / 2); if (flag) cout \u003c\u003c \"Of course,I can!\" \u003c\u003c endl; else cout \u003c\u003c \"Sorry,I can't!\" \u003c\u003c endl; } return 0; }   ","date":"2021-01-08","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/624/:0:0","tags":["acm","C/C++","动态规划","搜索","编程"],"title":"砝码问题","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/624/"},{"categories":["C/C++"],"content":"题目描述 已知元素从小到大排列的两个数组f[]和g[]，请写出一个程序算出两个数组彼此之间差的绝对值中最小的一个，这叫做数组的距离 输入 第一行为两个整数m, n(1≤m, n≤1000)，分别代表数组f[], g[]的长度。 第二行有m个元素，为数组f[]。 第三行有n个元素，为数组g[]。 输出 数组的最短距离 #include\u003cbits/stdc++.h\u003e using namespace std; int abs(int s); int main() { int a[10000],b[10000],c,d,i,n,min=99999,t; cin\u003e\u003ec\u003e\u003ed; for(i=0;i\u003cc;i++) { cin\u003e\u003ea[i]; } for(n=0;n\u003cd;n++) { cin\u003e\u003eb[n]; } for(i=0;i\u003cc;i++) { for(n=0;n\u003cd;n++) { t=abs(a[i]-b[n]); if(t\u003cmin) { min=t; } } } cout\u003c\u003cmin; return 0; } int abs(int s) { if(s\u003c0) return -s; else return s; }   ","date":"2021-01-08","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/622/:0:0","tags":["acm","C/C++","排序","编程"],"title":"数组的距离","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/622/"},{"categories":["C/C++"],"content":"题目描述 对于输入的每个字符串，查找其中的最大字母，在该字母后面插入字符串“(max)”。 输入 输入数据包括多个测试实例，每个实例由一行长度不超过100的字符串组成，字符串仅由大小写字母及数字构成 输出 对于每个测试实例输出一行字符串，输出的结果是插入字符串“(max)”后的结果，如果存在多个最大的字母，就在每一个最大字母后面都插入”(max)”。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { char a[100]; int len; int b[100]; char max; while(cin\u003e\u003ea) { len=strlen(a); max=a[0]; for(int i=0;i\u003clen;i++) { if(max\u003ca[i]) { max=a[i]; } } for(int i=0;i\u003clen;i++) { cout\u003c\u003ca[i]; if(a[i]==max) { cout\u003c\u003c\"(max)\"; } } cout\u003c\u003cendl; } return 0; }   ","date":"2021-01-08","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/620/:0:0","tags":["acm","C/C++","字符串","编程"],"title":"查找最大元素","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/620/"},{"categories":["C/C++"],"content":"题目描述 安徽科技学院校园里有一些小河和一些湖泊，现在，我们把它们通一看成水池，假设有一张我们学校的某处的地图，这个地图上仅标识了此处是否是水池，现在，你的任务来了，请用计算机算出该地图中共有几个水池。 输入 第一行输入一个整数N，表示共有N组测试数据 每一组数据都是先输入该地图的行数n(0输出 输出该地图中水池的个数。 要注意，每个水池的旁边（上下左右四个位置）如果还是水池的话的话，它们可以看做是同一个水池。 #include\u003cbits/stdc++.h\u003e using namespace std; #define MAXN 105 int dx[4]={0,-1,0,1}; int dy[4]={-1,0,1,0}; int mapp[MAXN][MAXN]; int m,n; void dfs(int x,int y){ mapp[x][y]=-1; for(int i=0;i\u003c4;i++){ int nx=x+dx[i]; int ny=y+dy[i]; if(nx\u003e=0 \u0026\u0026 nx\u003cm \u0026\u0026 ny\u003e=0 \u0026\u0026 ny\u003c=n \u0026\u0026 mapp[nx][ny]==1){ mapp[nx][ny]==-1; dfs(nx,ny); } } } int main(){ int T; scanf(\"%d\\n\",\u0026T); while(T--){ int ans=0; scanf(\"%d%d\",\u0026m,\u0026n); for(int i=0;i\u003cm;i++){ for(int j=0;j\u003cn;j++){ scanf(\"%d\",\u0026mapp[i][j]); } } for(int i=0;i\u003cm;i++){ for(int j=0;j\u003cn;j++){ if(mapp[i][j]==1){ dfs(i,j); ans++; } } } printf(\"%d\\n\",ans); } return 0; }   ","date":"2021-01-08","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/618/:0:0","tags":["acm","C/C++","搜索","编程","递归"],"title":"水池数目","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/618/"},{"categories":["C/C++"],"content":"题目描述 在一个群岛上，有一个富可敌国的大富翁。他打算在这个群岛上建造一个最大城堡，也就是群岛上最大的岛屿。 输入 第一行是一个整数T，代表测试数据的组数。每组数据中第一行是两个整数n,m，代表地图的大小。接下来n行每行共m个整数。0代表海洋，1代表陆地。其中T\u003c=50,n,m\u003c=200 输出 共T行，最大的面积。 #include \u003cbits/stdc++.h\u003e using namespace std; #define MAXN 205 int n, m; bool G[MAXN][MAXN]; int idx[MAXN][MAXN]; int iMax; void dfs(int r, int c, int id, int \u0026cnt) { if(r\u003c0 || r\u003e=n || c\u003c0 || c\u003e=m) return; if(G[r][c]==0 || idx[r][c]\u003e0) return; idx[r][c] = id; cnt++; dfs(r-1, c, id, cnt); dfs(r, c+1, id, cnt); dfs(r+1, c, id, cnt); dfs(r, c-1, id, cnt); } void doo() { memset(G, 0, sizeof(G)); memset(idx, 0, sizeof(idx)); iMax = 0; cin \u003e\u003e n \u003e\u003e m; for(int i=0; i\u003cn; i++) for(int j=0; j\u003cm; j++) cin \u003e\u003e G[i][j]; int id = 0; for(int i=0; i\u003cn; i++) for(int j=0; j\u003cm; j++) { int cnt = 0; if(G[i][j]==1 \u0026\u0026 idx[i][j]==0) dfs(i, j, ++id, cnt); if(cnt \u003e iMax) iMax = cnt; } cout \u003c\u003c iMax \u003c\u003c endl; } int main() { int T; cin \u003e\u003e T; while(T--) doo(); return 0; }  ","date":"2021-01-08","objectID":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/616/:0:0","tags":["acm","C/C++","搜索","编程"],"title":"雄伟的城堡","uri":"/2021/%E7%BC%96%E7%A8%8B/c-cpp/616/"},{"categories":["C/C++"],"content":"题目描述 假设货币有1,2,4,5,10五种硬币，每种数量都无限多，现在给出金额n(1输入 现在给出金额n(1输出 最少的硬币数量 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n; cin \u003e\u003e n; int a[n + 1] = { 0 }; int data[6] = { 0, 1, 2, 4, 5, 10 }; for (int i = 1; i \u003c= n; i++) a[i] = i; for (int i = 1; i \u003c= n; i++) for (int j = 1; j \u003c= 5; j++)if (data[j] \u003c= i)a[i] = min(a[i], a[i - data[j]] + 1); cout \u003c\u003c a[n] \u003c\u003c endl; return 0; }  ","date":"2020-12-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/601/:0:0","tags":["acm","C/C++","编程"],"title":"最优找零2","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/601/"},{"categories":["C/C++"],"content":"题目描述 长度为n但是不含11的字符串(只含01构成)有多少？（允许有前导0) 输入 一个正整数长度n(1输出 所有不含有11的字符串的总数由于数值很大，请输出对与1000000007取模的结果 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n; cin \u003e\u003e n; long long a[1001][2]; memset(a, 0, sizeof(a)); a[1][0] = 1; a[1][1] = 1; for (int i = 2; i \u003c= n; i++) { a[i][0] = (a[i - 1][0] + a[i - 1][1]) % 1000000007; a[i][1] = a[i - 1][0] % 1000000007; } cout \u003c\u003c (a[n][0] + a[n][1]) % 1000000007 \u003c\u003c endl; return 0; }  ","date":"2020-12-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/599/:0:0","tags":["acm","C/C++","编程"],"title":"不要11","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/599/"},{"categories":["C/C++"],"content":"题目描述 计算 区间[a,b]\"[a,b]的所有质数个数（1≤a\u003cb≤1000000\"1≤ab≤1000000） 输入 两个整数 a\"a,，b\"b 输出 区间[a,b]\"[a,b]的所有质数个数 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a, b; cin \u003e\u003e a \u003e\u003e b; int i, j; int count = 0; for (i = a; i \u003c= b; i++) { for (j = 2; j \u003c i; j++) { if (i % j == 0)break; } if (j == i) { count++; } } cout \u003c\u003c count \u003c\u003c endl; return 0; }   ","date":"2020-12-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/597/:0:0","tags":["acm","C/C++","编程"],"title":"区间质数统计","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/597/"},{"categories":["C/C++"],"content":"题目描述 对一个给定的自然数M，求出所有的连续的自然数段（连续个数大于1），这些连续的自然数段中的全部数之和为M。 例子：1998+1999+2000+2001+2002 = 10000，所以从1998到2002的一个自然数段为M=10000的一个解。 输入 包含一个整数的单独一行给出M的值（10 输出 每行两个自然数，给出一个满足条件的连续自然数段中的第一个数和最后一个数，两数之间用一个空格隔开，所有输出行的第一个按从小到大的升序排列，对于给定的输入数据，保证至少有一个解。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int m, k1, k2; cin \u003e\u003e m; for (k1 = sqrt(m * 2); k1 \u003e 1; k1--) if (2 * m % k1 == 0 \u0026\u0026 (k1 + 2 * m / k1) % 2 == 1) { k2 = 2 * m / k1; cout \u003c\u003c (k2 - k1 + 1) / 2 \u003c\u003c \" \" \u003c\u003c (k2 + k1 + 1) / 2 - 1 \u003c\u003c endl; } return 0; }   ","date":"2020-12-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/595/:0:0","tags":["acm","C/C++","编程"],"title":"连续和","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/595/"},{"categories":["C/C++"],"content":"题目描述 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 (图一) 图一表示一个5行的数字三角形。假设给定一个n行数字三角形,计算出从三角形顶至底的一条路径，使该路径经过的数字总和最大。 每一步只能由当前位置向下或向右下。 输入 你的程序要能接受标准输入。第一行包含一个整数T，表示总的测试次数。 对于每一种情况：第一行包含一个整数N,其中1 接下来的N行输入表示三角形的每一行的元素Ai,j，其中0 输出 输出每次测试的最大值并且占一行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n, i, j, a[110][110] = { 0 }; int t; scanf(\"%d\", \u0026t); while (t--) { scanf(\"%d\\n\", \u0026n); for (i = 0; i \u003c= n - 1; i++) { for (j = 0; j \u003c= i; j++) { scanf(\"%d\\n\", \u0026a[i][j]); } } for (i = n - 2; i \u003e= 0; i--) { for (j = 0; j \u003c= i; j++) { a[i][j] = a[i][j] + max(a[i + 1][j], a[i + 1][j + 1]); } } printf(\"%d\\n\", a[0][0]); } return 0; }   ","date":"2020-12-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/593/:0:0","tags":["acm","C/C++","编程"],"title":"数字三角形","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/593/"},{"categories":["C/C++"],"content":"题目描述 给定 n 位正整数 a，去掉其中任意 k≤n 个数字后，剩下的数字按原次序排列组成一个新的正整数。对于给定的 n 位正整数 a 和正整数 k，设计一个算法找出剩下数字组成的新数最小的删数方案。 算法设计： 对于给定的正整数 a，计算删去 k 个数字后得到的最小数。 输入 输入第 1 行是 1 个正整数 a。第 2 行是正整数 k。 输出 输出最小数 #include\u003cbits/stdc++.h\u003e using namespace std; #define L 101 int main() { int i, j, k, m, n, t, c; char ch[L], s; while (~scanf(\"%s %d\", ch, \u0026n)) { while (n--) { m = strlen(ch); for (i = 0; i \u003c m; i++) { if (ch[i] \u003e ch[i + 1]) { for (j = i; ch[j] != 0; j++) { ch[j] = ch[j + 1]; } break; } } } c = 0; for (i = 0; ch[i] != 0; i++) { if (ch[i] != '0' || (ch[i] == '0' \u0026\u0026 c)) { printf(\"%c\", ch[i]); c++; } } if (c)printf(\"\\n\"); else printf(\"0\\n\"); } return 0; }   ","date":"2020-12-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/589/:0:0","tags":["acm","C/C++","编程"],"title":"删数问题","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/589/"},{"categories":["C/C++"],"content":"题目描述 给你一个非负数整数n，判断n是不是一些数（这些数不允许重复使用，且为正数）的阶乘之和，如9=1！+2!+3!，如果是，则输出Yes，否则输出No； 输入 第一行有一个整数0输出 如果符合条件，输出Yes，否则输出No; #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a[10], i, m, t, s = 1; a[0] = 0; for (i = 1; i \u003c= 9; ++i) { s *= i; a[i] = s; } scanf(\"%d\", \u0026t); while (t--) { scanf(\"%d\", \u0026m); for (i = 9; i \u003e= 1; --i) { if (m \u003e= a[i]) m -= a[i]; if (!m) break; } if (!m)printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0; }  ","date":"2020-12-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/587/:0:0","tags":["acm","C/C++","编程"],"title":"阶乘之和","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/587/"},{"categories":["C/C++"],"content":"题目描述 作为安科大的老师，最盼望的日子就是每月的9号了，因为这一天是发工资的日子，养家糊口就靠它了，呵呵 但是对于学校财务处的工作人员来说，这一天则是很忙碌的一天，财务处的小胡老师最近就在考虑一个问题：如果每个老师的工资额都知道，最少需要准备多少张人民币，才能在给每位老师发工资的时候都不用老师找零呢？ 这里假设老师的工资都是正整数，单位元，人民币一共有100元、50元、20元、10元、5元、2元和1元七种。 输入 输入数据包含多个测试实例，每个测试实例的第一行是一个整数n（n输出 对于每个测试实例输出一个整数x,表示至少需要准备的人民币张数。每个输出占一行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { const int cur[7] = { 100,50,20,10,5,2,1 }; int teacher[100]; int num; while (cin \u003e\u003e num) { if (num != 0) { int sum = 0; for (int i = 0; i \u003c num; i++) cin \u003e\u003e teacher[i]; for (int j = 0; j \u003c num; j++) { for (int k = 0; k \u003c 7; k++) { sum += teacher[j] / cur[k]; teacher[j] %= cur[k]; } } cout \u003c\u003c sum \u003c\u003c endl; } else break; } }   ","date":"2020-12-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/585/:0:0","tags":["acm","C/C++","编程"],"title":"给老师发工资","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/585/"},{"categories":["C/C++"],"content":"题目描述 输入一个正整数n，求Fibonacci数列的第n个数。Fibonacci数列的特点：第1,2个数为1,1。从第3个数开始，概述是前面两个数之和。即： 要求输入的正整数n不超过50. 输入 一个不超过50的正整数 输出 Fibonacci数列的第n个数，末尾输出换行。 递归法（使用数组记录已经算过的斐波那契数） #include\u003cbits/stdc++.h\u003e using namespace std; uint64_t Fibonacci(unsigned char n) { static uint64_t fib[256] = { 0, 1 }; if (n == 0) return 0; if (fib[n] != 0) return fib[n]; fib[n] = Fibonacci(n - 1) + Fibonacci(n - 2); return fib[n]; } int main() { int n; cin \u003e\u003e n; cout \u003c\u003c Fibonacci(n); } 递推法 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { long long sum = 1, pre_sum = 0, cre_sum; int i; scanf(\"%d\", \u0026i); while (--i){ cre_sum = sum; sum += pre_sum; pre_sum = cre_sum; } printf(\"%lld\\n\", sum); return 0; }  ","date":"2020-12-30","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/583/:0:0","tags":["acm","C/C++","编程"],"title":"快速计算斐波那契数列（Fibonacci数列）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/583/"},{"categories":["C/C++"],"content":"题目描述 新学期开始了，小哈是小哼的新同，小哼向小哈询问QQ号，小哈当然不会直接告诉小哼。所以小哈给了小哼一串加密过的数字，同时小哈也告诉了小哼解密规则。规则是这样的：首先将第1个数删除，紧接着将第2个数放到这串数的末尾，再将第3个数删除并将第4个数再放到这串数的末尾，再将第5个数删除……直到剩下最后一个数，将最后一个数也删除。按照刚才删除的顺序，把这些删除的数连在一起就是小哈的QQ啦。现在你来帮帮小哼吧。小哈给小哼加密过的一串数是“6 3 1 7 5 8 9 2 4”。解密后小哈的QQ号应该是“6 1 5 9 4 7 2 8 3”。 输入 只有2行 第1行有一个整数n （1输出 只有一行，输出解密后的QQ号。 _使用****标准库_ #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n, i, x; queue\u003cint\u003e q; cin \u003e\u003e n; for (i = 0; i \u003c n; i++) { cin \u003e\u003e x; q.push(x); } while (!q.empty()) { cout \u003c\u003c q.front() \u003c\u003c \" \"; q.pop(); if (q.empty())break; else { q.push(q.front()); q.pop(); } } return 0; }  ","date":"2020-12-29","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/579/:0:0","tags":["acm","C/C++","编程"],"title":"解密QQ号","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/579/"},{"categories":["C/C++"],"content":"题目描述 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。 输入 输入有2行 第1行为1个正整数，表示所生成的随机数的个数：N 第2行有N个用空格隔开的正整数，为所产生的随机数。 输出 输出也是2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。 常规解法 #include\u003ciostream\u003e using namespace std; int main(){ int N,n; int a[1000]; int i,j,k; while(scanf(\"%d\",\u0026n)!=EOF){ for(i=0; i\u003cn; i++) scanf(\"%d\",\u0026a[i]); //去重 for(i=0; i\u003cn; i++) for(j=i+1; j\u003cn; j++){ if(a[j]==a[i]){ for(k=j; k\u003cn-1; k++) a[k]=a[k+1]; n--; j--; } } //冒泡排序 for(i=0; i\u003cn-1; i++) for(j=0; j\u003cn-1-i; j++){ if(a[j]\u003ea[j+1]){ int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } for(i=0; i\u003cn; i++){ cout\u003c\u003ca[i]\u003c\u003cendl; } } } 奇技淫巧 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n, a[101], i; cin \u003e\u003e n; for (i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; } sort(a, a + n); int t = unique(a, a + n) - a; cout \u003c\u003c t \u003c\u003c endl; for (i = 0; i \u003c t; i++) { cout \u003c\u003c a[i] \u003c\u003c \" \"; } } 网传大佬解法 #include\u003cbits/stdc++.h\u003e using namespace std; int n,k,i,a[1001],x; int main() { cin\u003e\u003en; memset(a,0,sizeof(a)); for(i=1;i\u003c=n;i++) { cin\u003e\u003ex; if(a[x]==0) k++; a[x]++; } cout\u003c\u003ck\u003c\u003cendl; for(int i=1;i\u003c=1000;i++) if(a[i]\u003e0) cout\u003c\u003ci\u003c\u003c\" \"; return 0; }  ","date":"2020-12-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/577/:0:0","tags":["acm","C/C++","编程"],"title":"明明的随机数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/577/"},{"categories":["C/C++"],"content":"题目描述 折半插入排序同样是一种非常简单的排序方法，它的基本操作是在一个已经排好序的有序表中进行查找和插入。不难发现这个查找的过程可以十分自然的修改成折半查找的方式进行实现。 折半插入排序的算法可以描述如下： 在本题中，读入一串整数，将其使用以上描述的折半插入排序的方法从小到大排序，并输出。 输入 输入的第一行包含1个正整数n，表示共有n个整数需要参与排序。其中n不超过1000。 第二行包含n个用空格隔开的正整数，表示n个需要排序的整数。 输出 只有1行，包含n个整数，表示从小到大排序完毕的所有整数。 请在每个整数后输出一个空格，并请注意行尾输出换行。 #include\u003cbits/stdc++.h\u003e using namespace std; int a[1005]; int main(){ int n; cin\u003e\u003en; for(int i=0;i\u003cn;i++) cin\u003e\u003ea[i]; int low,high,mid; for(int i=1;i\u003cn;i++){ int low=0;high=i-1; int k=a[i]; while(low\u003c=high){ mid=(low+high)\u003e\u003e1; if(a[i]\u003ca[mid]) high=mid-1; else low =mid+1; } for(int j=i;j\u003e=low+1;j--) a[j]=a[j-1]; a[low]=k; } for(int i=0;i\u003cn;i++) cout\u003c\u003ca[i]\u003c\u003c\" \"; cout\u003c\u003cendl; return 0; }  ","date":"2020-12-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/572/:0:0","tags":["acm","C/C++","编程"],"title":"折半插入排序","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/572/"},{"categories":["C/C++"],"content":"题目描述 写一个函数，实现两个字符串的比较过程。即自己写一个strcmp函数，函数的原型为：int strcmp(char *p1, char *p2)。设p1指向字符串s1，p2指向字符串s2。要求当s1=s2时，返回值为0；若s1≠s2，返回它们二者第一个不同字符的ASCII码差值（例如”BOY”与”BAD”，第二个字母不同，’O’与’A’只差为79-65=14）。如果s1s2，则输出正值；如果s1输入 有两行，每行有一个不包含空格的字符串，即参与比较的两个字符串。保证每个字符串的长度都不超过200。 输出 只有一个整数，即strcmp比较两个字符串的返回值。 请注意行尾输出换行。 #include\u003cbits/stdc++.h\u003e using namespace std; int m, n; int main() { int strcmp(char* p1, char* p2); char ch[200], zh[200]; int t; gets(ch); gets(zh); m = strlen(ch); n = strlen(zh); t = strcmp(ch, zh); printf(\"%d\", t); return 0; } int strcmp(char* p1, char* p2) { int i, k; for (i = 0; i \u003c m; i++) { if (*(p1 + i) != *(p2 + i)) { k = *(p1 + i) - *(p2 + i); return k; } } if (i \u003e= m) { return 0; } }   ","date":"2020-12-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/570/:0:0","tags":["acm","C/C++","编程"],"title":"比较并计算字符串的差值","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/570/"},{"categories":["C/C++"],"content":"题目描述 在main函数中输入10个不等长的字符串，另外写一个函数对它们按字典序从小到大排序。并在main函数中输出这10个已经排好序的字符串。 输入 共有10行，每行一个字符串。输入保证每行的字符串长度不超过100个字符。请注意字符串中有可能包含空格。 输出 与输入格式相同，每行输出一个排好序之后的字符串。 请注意行尾输出换行。 #include\u003cbits/stdc++.h\u003e using namespace std; static void ranks(char* p) { int i, j, k = 0; char temp[50]; for (i = 0; i \u003c 9; i++) { k = i; for (j = i + 1; j \u003c 10; j++) if (strcmp(p + k * 50, p + j * 50) \u003e 0) k = j; if (k != i) { strcpy(temp, p + i * 50); strcpy(p + i * 50, p + k * 50); strcpy(p + k * 50, temp); } } } int main() { char str[10][50]; int i; char* p = str[0]; for (i = 0; i \u003c 10; i++) { gets(str[i]); } ranks(p); for (i = 0; i \u003c 10; i++) printf(\"%s\\n\", str[i]); return 0; }  ","date":"2020-12-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/568/:0:0","tags":["acm","C/C++","编程"],"title":"字符串的字典序排序","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/568/"},{"categories":["C/C++"],"content":"题目描述 Selection Sort Write a program of the Selection Sort algorithm which sorts a sequence A in ascending order. The algorithm should be based on the following pseudocode: SelectionSort(A) 1 for i = 0 to A.length-1 2 mini = i 3 for j = i to A.length-1 4 if A[j] 5 mini = j 6 swap A[i] and A[mini] Note that, indices for array elements are based on 0-origin. Your program should also print the number of swap operations defined in line 6 of the pseudocode in the case where i ≠ mini. 输入 The first line of the input includes an integer N, the number of elements in the sequence. In the second line, N elements of the sequence are given separated by space characters. 输出 The output consists of 2 lines. In the first line, please print the sorted sequence. Two contiguous elements of the sequence should be separated by a space character. In the second line, please print the number of swap operations. #include\u003cbits/stdc++.h\u003e typedef long long ll; using namespace std; int a[110]; int main(){ ios::sync_with_stdio(false); int n; cin\u003e\u003en; for(int i = 1 ; i\u003c=n ; i++){ cin\u003e\u003ea[i]; } int ans = 0; for(int i = 1 ; i\u003c=n-1 ; i++){ int min = a[i]; int flag = i; for(int j = i+1 ; j\u003c=n ; j++){ if(min \u003e a[j]){ flag = j; min = a[j]; } } if(flag != i){ swap(a[flag] , a[i] ); ans++; } } for(int i = 1 ; i\u003c=n ; i++){ if(i == 1) cout\u003c\u003ca[i]; else{ cout\u003c\u003c\" \"\u003c\u003ca[i]; } } cout\u003c\u003cendl; cout\u003c\u003cans\u003c\u003cendl; return 0; }  ","date":"2020-12-24","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/560/:0:0","tags":["acm","C/C++","编程"],"title":"Sort I-Selection Sort","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/560/"},{"categories":["C/C++"],"content":"题目描述 排序，顾名思义，是将若干个元素按其大小关系排出一个顺序。形式化描述如下：有n个元素a[1]，a[2]，…，a[n]，从小到大排序就是将它们排成一个新顺序a[i[1]]输入 第一行一个正整数n，表示元素个数 第二行为n个整数，以空格隔开 输出 共n行，每行输出第n步选择时交换哪两个位置的下标，以及交换得到的序列，格式: swap(a[i],a[j]):a[0] … a[n-1] i和j为所交换元素的下标，下标从0开始，最初元素顺序按输入顺序。另外请保证i#include\u003cbits/stdc++.h\u003e using namespace std; int n; void sorts(int* a, int b) { if (b == n) return; int min = a[b]; int t = b; for (int i = b + 1; i \u003c n; ++i) { if (min \u003e a[i]) { min = a[i]; t = i; } } int x = a[b]; a[b] = a[t]; a[t] = x; printf(\"swap(a[%d], a[%d]):%d\", b, t, a[0]); for (int i = 1; i \u003c n; ++i) printf(\" %d\", a[i]); printf(\"\\n\"); sorts(a, b + 1); } int main() { int a[105] = { 0 }; cin \u003e\u003e n; for(int i = 0; i \u003c n; ++i)cin \u003e\u003e a[i]; sorts(a, 0); return 0; }  ","date":"2020-12-22","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/526/:0:0","tags":["acm","C/C++","编程"],"title":"选择排序（蓝桥杯）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/526/"},{"categories":["C/C++"],"content":"题目描述 古希腊数学家毕达哥拉斯在自然数研究中发现，220\"220220的所有真约数(即不是自身的约数)之和为：1+2+4+5+10+11+20+22+44+55+110＝284\"1+2+4+5+10+11+20+22+44+55+110＝284 而284\"284的所有真约数为1\"1、2\"2、4\"4、71\"71、142\"142，加起来恰好为220\"220。人们对这样的数感到很惊奇，并称之为亲和数。一般地讲，如果两个数中任何一个数都是另一个数的真约数之和，则这两个数就是亲和数。 你的任务就编写一个程序，判断给定的两个数是否是亲和数 输入 输入数据第一行包含一个数M\"M，接下有M\"M行，每行一个实例,包含两个整数A\"AA,B\"BB； 其中 0≤A,B≤6∗105\"≤A,B≤6∗105; 输出 对于每个测试实例，如果A\"A和B\"B是亲和数的话输出YES，否则输出NO。 #include\u003cbits/stdc++.h\u003e using namespace std; int yue(int a) { int i = 1, t = 0; while (i \u003c a) { if (a % i == 0 ) { t += i; } i++; } return t; } int main() { int m, x,y,a,b; cin \u003e\u003e m; while (m--) { cin \u003e\u003e x \u003e\u003e y; if (y == yue(x) \u0026\u0026 x == yue(y))cout \u003c\u003c \"YES\" \u003c\u003c endl; else cout \u003c\u003c \"NO\" \u003c\u003c endl; } }  ","date":"2020-12-21","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/524/:0:0","tags":["acm","C/C++","编程"],"title":"亲和数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/524/"},{"categories":["C/C++"],"content":"题目描述 验证尼科彻斯定理，即：任何一个正整数的立方都可以写成一串连续奇数的和。 输入 任一正整数 输出 该数的立方分解为一串连续奇数的和 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int x; scanf(\"%d\", \u0026x); long long y = x * x * x; printf(\"%d*%d*%d=%lld=\", x, x, x, y); y = x * x - x + 1; for (int i = 0; i \u003c x-1; i++) { cout \u003c\u003c y \u003c\u003c \"+\"; y += 2; } cout \u003c\u003c y; return 0; }  ","date":"2020-12-19","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/520/:0:0","tags":["acm","C/C++","编程"],"title":"尼科彻斯定理","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/520/"},{"categories":["C/C++"],"content":"题目描述 一条单链表可以表示一个一元多项式，每个节点包含三个域：指数、系数和后继节点（指针或引用）。 表示多项式3X4-6X2+5X-10的单链表如图所示。给定两个多项式，实现两个多项式相加算法。 输入 第一行输入包含两个整数m,n 后续为m行和n行数据 m，n分别代表两个多项式的项数 后续每一行代表多项式的项，包含a,b两个数据，表示该项的系数和指数。 输出 从较高指数到较低指数，依次输出求得的和。 每行一项，格式与输入相同，但无需输出项数，系数为0的项也不输出。 #include\u003cbits/stdc++.h\u003e using namespace std; typedef struct { double xs; double zs; } Term; typedef struct ploy { Term term; ploy* next; } ploy, * LinkList; void Li(LinkList\u0026 L) { L = (ploy*)malloc(sizeof(ploy)); L-\u003eterm.xs = 0.0; L-\u003eterm.zs = -1; L-\u003enext = NULL; } int cmp(Term a, Term b) { if (a.zs \u003c b.zs) return 1; else if (a.zs == b.zs) return 0; else return -1; } void in(LinkList\u0026 L, Term e) { ploy* q = L; while (q-\u003enext != NULL) { if (cmp(q-\u003enext-\u003eterm, e) \u003c 0) q = q-\u003enext; else break; } if (q-\u003enext != NULL \u0026\u0026 cmp(q-\u003enext-\u003eterm, e) == 0) { q-\u003enext-\u003eterm.xs += e.xs; } else { ploy* node = (ploy*)malloc(sizeof(ploy)); node-\u003eterm.xs = e.xs; node-\u003eterm.zs = e.zs; if (q-\u003enext == NULL) node-\u003enext = NULL; else node-\u003enext = q-\u003enext; q-\u003enext = node; } } void CP(LinkList\u0026 L, int m) { Term e; Li(L); for (int i = 1; i \u003c= m; i++) { cin \u003e\u003e e.xs \u003e\u003e e.zs; in(L, e); } } void add(LinkList\u0026 L1, LinkList\u0026 L2) { ploy* q; for (q = L2-\u003enext; q != NULL; q = q-\u003enext) { in(L1, q-\u003eterm); } free(L2); } void SubtracatPolyn(LinkList\u0026 L1, LinkList\u0026 L2) { ploy* q; for (q = L2-\u003enext; q != NULL; q = q-\u003enext) { q-\u003eterm.xs = -(q-\u003eterm.xs); in(L1, q-\u003eterm); } free(L2); } void visitList(LinkList L) { ploy* q = L; while (q-\u003enext != NULL) { q = q-\u003enext; if (q-\u003eterm.xs != 0) { cout \u003c\u003c q-\u003eterm.xs \u003c\u003c \" \" \u003c\u003c q-\u003eterm.zs \u003c\u003c endl; } } } int main() { LinkList L1, L2; int n1, n2; cin \u003e\u003e n1 \u003e\u003e n2; CP(L1, n1); CP(L2, n2); add(L1, L2); visitList(L1); return 0; }   ","date":"2020-12-18","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/517/:0:0","tags":["acm","C/C++","编程"],"title":"多项式相加","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/517/"},{"categories":["C/C++"],"content":"题目描述 大家都知道，考研包括初试和复试，院校根据初试成绩和复试成绩综合决定是否录取你，具体的计算总成绩的方案是(初试总成绩)*0.6+(复试成绩)*0.4.这不Pmathticol还没玩够，又要开始准备万恶的复试了。不仅如此，对各科也还都有要求，所以院校会划定各科成绩线要求以及总分要求，只有过了各个单科分数线且总分足够才有资格进入复试。另外若是复试分数(满分为100分)不及格，则也不被录取。假定录取名额没有限制，只要符合上述条件的就被录取。我们知道初试科目包括数学，英语，政治，专业课。给定n个同学的各科成绩和复试成绩(假设每位同学都有复试成绩)，以及报考院校的各个单科分数线和总分线。要你求最后被录取的名单以及他们的相关信息。 输入 只有一组测试数据， 第一行是报考院校的单科要求(英语，政治，数学，专业)和总分要求 接下来包括n名同学(10输出 输出被录取的同学信息(姓名 初试成绩 复试成绩 总成绩 复试序号)，并按照最终成绩从高到低排序。成绩相同的，按照名字字母顺序先后排序。所有的数据都用double型输入，最后结果初试和复试成绩四舍五入为整数输出，总成绩保留1位小数。 #include\u003cbits/stdc++.h\u003e using namespace std; struct stu { string s; double a, b, c, d, e, f, g; }k[50]; bool q(stu A, stu B) { if (A.g != B.g) { return A.g \u003e B.g; } else { return A.s \u003c A.s; } } int x, y, z, r, p, j, i = 0, t = 1; int main() { for (cin \u003e\u003e x \u003e\u003e y \u003e\u003e z \u003e\u003e r \u003e\u003e p; cin \u003e\u003e k[i].s \u003e\u003e k[i].a \u003e\u003e k[i].b \u003e\u003e k[i].c \u003e\u003e k[i].d \u003e\u003e k[i].e;) { k[i].f = k[i].a + k[i].b + k[i].c + k[i].d, k[i].g = k[i].f * 0.6 + k[i].e * 0.4; if (k[i].a \u003e= x \u0026\u0026 k[i].b \u003e= y \u0026\u0026 k[i].c \u003e= z \u0026\u0026 k[i].d \u003e= r \u0026\u0026 k[i].f \u003e= p)i++; sort(k, k + i, q); } for (j = 0; j \u003c i; j++) cout \u003c\u003c k[j].s.c_str() \u003c\u003c fixed \u003c\u003c setprecision(0) \u003c\u003c \" \" \u003c\u003c setprecision(0) \u003c\u003c k[j].f \u003c\u003c \" \" \u003c\u003c setprecision(0) \u003c\u003c k[j].e \u003c\u003c \" \" \u003c\u003c setprecision(1) \u003c\u003c k[j].g \u003c\u003c \" \" \u003c\u003c t++ \u003c\u003c endl; return 0; }  ","date":"2020-12-18","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/515/:0:0","tags":["acm","C/C++","编程"],"title":"分！分！分! 学生的命根","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/515/"},{"categories":["C/C++"],"content":"题目描述 完成一个对候选人得票的统计程序。假设有3个候选人，名字分别为Li，Zhang和Fun。使用结构体存储每一个候选人的名字和得票数。记录每一张选票的得票人名，输出每个候选人最终的得票数。结构体可以定义成如下的格式： struct person { char name[20]; int count; }leader[3] = {“Li”, 0, “Zhang”, 0, “Fun”, 0}; 输入 第一行有一个整数n，表示以下有n张选票信息将会输入。保证n不大于100。 以后的n行中，每一行包含一个人名，为选票的得票人。保证每一个人名都是Li，Zhang和Fun中的某一个。 输出 有三行，分别为Li，Zhang和Fun每人的得票数。格式为首先输出人名，其后输出一个冒号，最后输出候选人的得票数。 请注意行尾输出换行。 #include\u003cbits/stdc++.h\u003e using namespace std; struct person{ char name[20]; int count; }leader[3]={\"Li\",0,\"Zhang\",0,\"Fun\",0}; int main(){ int n; char name1[20]; scanf(\"%d\",\u0026n); for(int i=0;i\u003cn;i++){ scanf(\"%s\",name1); for(int j=0;j\u003c3;j++){ if(strcmp(leader[j].name,name1)==0) leader[j].count++; } } printf(\"Li:%d\\n\",leader[0].count); printf(\"Zhang:%d\\n\",leader[1].count); printf(\"Fun:%d\",leader[2].count); return 0; }  ","date":"2020-12-18","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/513/:0:0","tags":["acm","C/C++","编程"],"title":"候选人得票","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/513/"},{"categories":["C/C++"],"content":"题目描述 现在有很多长方形，每一个长方形都有一个编号，这个编号可以重复；还知道这个长方形的宽和长，编号、长、宽都是整数；现在要求按照一下方式排序（默认排序规则都是从小到大）； 1.按照编号从小到大排序 2.对于编号相等的长方形，按照长方形的长排序； 3.如果编号和长都相同，按照长方形的宽排序； 4.如果编号、长、宽都相同，就只保留一个长方形用于排序,删除多余的长方形；最后排好序按照指定格式显示所有的长方形； 输入 第一行有一个整数 0每一组第一行有一个整数 0接下来的m行，每一行有三个数 ，第一个数表示长方形的编号，第二个和第三个数值大的表示长，数值小的表示宽相等，说明这是一个正方形（数据约定长宽与编号都小于10000）；输出 顺序输出每组数据的所有符合条件的长方形的 编号 长 宽 #include \u003ciostream\u003e #include \u003calgorithm\u003e using namespace std; struct node { int number, len, width; }P[1005]; bool cmp (node a, node b) { if (a.number != b.number) return a.number\u003cb.number; if (a.len != b.len) return a.len\u003cb.len; return a.width\u003cb.width; } int main() { int N; cin \u003e\u003eN; while (N –) { int m; cin \u003e\u003em; for (int i=0; i\u003cm; ++i) { int a, b, c; cin \u003e\u003ea \u003e\u003eb \u003e\u003ec; P[i].number = a; P[i].len = max(b, c); P[i].width = min(b, c); } sort (P, P+m, cmp); cout \u0026lt;\u0026lt;P[0].number \u0026lt;\u0026lt;\" \" \u0026lt;\u0026lt;P[0].len \u0026lt;\u0026lt;\" \" \u0026lt;\u0026lt;P[0].width \u0026lt;\u0026lt;endl; for (int i=1; i\u0026lt;m; ++i) { if (P[i].number == P[i-1].number \u0026\u0026 P[i].len == P[i-1].len \u0026\u0026 P[i].width == P[i-1].width) continue; cout \u0026lt;\u0026lt;P[i].number \u0026lt;\u0026lt;\" \" \u0026lt;\u0026lt;P[i].len \u0026lt;\u0026lt;\" \" \u0026lt;\u0026lt;P[i].width \u0026lt;\u0026lt;endl; } } return 0; }   ","date":"2020-12-18","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/508/:0:0","tags":["acm","C/C++","编程"],"title":"一种排序","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/508/"},{"categories":["未分类"],"content":"#include \u003ciostream\u003e #include \u003cmap\u003e using namespace std; struct ploy { int m; map\u003cint, int\u003e mp; void input() { for (int i = 0; i \u003c m; i++) { int coef, index; cin \u003e\u003e coef \u003e\u003e index; mp[index] = coef; } } void add(ploy \u0026that) { this-\u003em = this-\u003em \u003e that.m ? this-\u003em : that.m; for (int i = 0; i \u003c= m; i++) mp[i] += that.mp[i]; } void disp() { for (int i = m; i \u003e= 0; i--) if (mp[i]) cout \u003c\u003c mp[i] \u003c\u003c \" \" \u003c\u003c i \u003c\u003c endl; } }; int main(int argc, char const *argv[]) { for (ploy a, b; cin \u003e\u003e a.m \u003e\u003e b.m;) { a.input(); b.input(); a.add(b); a.disp(); } return 0; }  ","date":"2020-12-18","objectID":"/2020/uncategorized/506/:0:0","tags":null,"title":"多项式相加","uri":"/2020/uncategorized/506/"},{"categories":["C/C++"],"content":"题目描述 小王是公司的仓库管理员，一天，他接到了这样一个任务：从仓库中找出一根钢管。这听起来不算什么，但是这根钢管的要求可真是让他犯难了，要求如下： 1、 这根钢管一定要是仓库中最长的； 2、 这根钢管一定要是最长的钢管中最细的； 3、 这根钢管一定要是符合前两条的钢管中编码最大的（每根钢管都有一个互不相同的编码，越大表示生产日期越近）。 相关的资料到是有，可是，手工从几百份钢管材料中选出符合要求的那根…… 要不，还是请你编写个程序来帮他解决这个问题吧。 输入 第一行是一个整数N(N输出 对应每组测试数据的输出只有一个9位整数，表示选出的那根钢管的编码， 每个输出占一行 #include\u003cbits/stdc++.h\u003e using namespace std; struct Pipe { int length, diameter, number; }; void input(Pipe\u0026 p) { cin \u003e\u003e p.length \u003e\u003e p.diameter \u003e\u003e p.number; } Pipe pipes[1000]; int n; bool cmp(Pipe a, Pipe b) { if (a.length != b.length)return a.length \u003e b.length; if (a.diameter != b.diameter)return a.diameter \u003c b.diameter; return a.number \u003e b.number; } int main() { int T; cin \u003e\u003e T; while (T--) { cin \u003e\u003e n; for (int i = 0; i \u003c n; ++i)input(pipes[i]); sort(pipes, pipes + n, cmp); cout \u003c\u003c pipes[0].number \u003c\u003c endl; } return 0; }  ","date":"2020-12-17","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/504/:0:0","tags":["acm","C/C++","编程"],"title":"精挑细选","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/504/"},{"categories":["C/C++"],"content":"题目描述 现在有一群同学都想结成异姓兄弟，规定按照年龄大小来从大到小排序。你来搜集这些同学的信息：姓名和对应的出生年月日。且他们不存在同年同月同日生的情况，你来帮助他们排个序。 输入 输入第一行有一个整数N(0输出 请按从大到小的顺序输出所有同学的姓名。 假设不存在同年同月同日生的同学。 #include\u003cbits/stdc++.h\u003e using namespace std; struct Person { char name[100]; int y, m, d; }; const int maxn = 1000 + 10; Person p[maxn]; int n; bool cmp(Person a, Person b) { if (a.y != b.y)return a.y \u003c b.y; if (a.m != b.m)return a.m \u003c b.m; return a.d \u003c b.d; } int main() { cin \u003e\u003e n; for (int i = 0; i \u003c n; i++)cin \u003e\u003e p[i].name \u003e\u003e p[i].y \u003e\u003e p[i].m \u003e\u003e p[i].d; sort(p, p + n, cmp); for (int i = 0; i \u003c n; i++)cout \u003c\u003c p[i].name \u003c\u003c endl; return 0; }  ","date":"2020-12-17","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/502/:0:0","tags":["acm","C/C++","编程"],"title":"结义兄弟","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/502/"},{"categories":["C/C++"],"content":"题目描述 A+B非常经典，同学们也非常喜欢，这不老师也给大家出一个A+B的问题：设电子表格式为24小时制的 HH:MM:SS 输入一个电子表上的时间A,经过时间B后，电子表上显示的时间是多少呢？ 输入 多组输入 每一行为一组测试数据包含六个整数 表示两个时间数据A B格式为时分秒 输出 每组数据输出A时刻开始B时间段后所对应的时间 #include\u003cbits/stdc++.h\u003e using namespace std; struct times{ int h, m, s,hh,mm,ss; }; void input(times\u0026 c) { cin \u003e\u003ec.m \u003e\u003e c.s \u003e\u003e c.hh \u003e\u003e c.mm \u003e\u003e c.ss; } int main() { times x; int h,a,b,c; while (cin \u003e\u003e h) { input(x); a = h + x.hh; b = x.m + x.mm; c = x.s + x.ss; while (c \u003e= 60) { b = b + 1; c = c - 60; } while (b \u003e= 60) { a = a + 1; b = b - 60; } while (a \u003e=24) { a = a - 24; } printf(\"%02d:%02d:%02d\\n\", a, b, c); } return 0; }  ","date":"2020-12-17","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/498/:0:0","tags":["acm","C/C++","编程"],"title":"电子表A+B","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/498/"},{"categories":["C/C++"],"content":"题目描述 C++编程考试使用的实时提交系统，具有即时获得成绩排名的特点。它的功能是怎么实现的呢？ 我们做好了题目的解答，提交之后，要么“AC”，要么错误，不管怎样错法，总是给你记上一笔，表明你曾经有过一次错误提交，因而当你一旦提交该题 “AC”后，就要与你算一算帐了，总共该题错误提交了几回。虽然你在题数上，大步地跃上了一个台阶，但是在耗时上要摊上你共花去的时间。特别是，曾经有过 的错误提交，每次都要摊上一定的单位时间分。这样一来，你在做出的题数上，可能领先别人很多，但是，在做出同样题数的人群中，你可能会在耗时上处于排名的 劣势。 例如：某次考试一共8题（A，B，C，D，E，F，G，H），每个人做的题都在对应的题号下有个数量标记，负数表示该学生在该题上有过的错误提交 次数，但到现在还没有AC，正数表示AC所耗的时间，如果正数a跟上一对括号，里面有个整数b，那就表示该学生提交该题AC了，耗去了时间a，同时，曾经 错误提交了b次，因此对于下述输入数据： name A B C D E F G H Smith -1 -16 8 0 0 120 39 0 John 116 -2 11 0 0 82 55(1) 0 Jose 72(3) 126 10 -3 0 47 21(2) -2 Bush 0 -1 -8 0 0 0 0 0 Alice -2 67(2) 13 -1 0 133 79(1) -1 Bob 0 0 57(5) 0 0 168 -7 0 若每次错误提交的罚分为20分，则其排名从高到低应该是这样的： Jose 5 376 John 4 284 Alice 4 352 Smith 3 167 Bob 2 325 Bush 0 0 输入 输入数据的第一行是考试题数n（1≤n≤12）以及单位罚分数 m（10≤m≤20），每行数据描述一个学生的用户名（不多于10个字符的字串）以及对所有n道题的答题现状，其描述采用问题描述中的数量标记的格式，见 上面的表格，提交次数总是小于100，AC所耗时间总是小于1000。 输出 将这些学生的考试现状，输出一个实时排名。实时排名显然先按AC题数的多 少排，多的在前，再按时间分的多少排，少的在前，如果凑巧前两者都相等，则按名字的字典序排，小的在前。每个学生占一行，输出名字（10个字符宽），做出 的题数（2个字符宽，右对齐）和时间分（4个字符宽，右对齐）。名字、题数和时间分相互之间有一个空格。 #include\u003cbits/stdc++.h\u003e using namespace std; int cnt, litter; //cnt为需要计算的题数，litter为惩罚时间 struct pupil { string name; int ac_t; //ac的题目数量 int time; //题目的时间 } tmp; int total_ac = 0, total_time = 0; struct rule { bool operator()(const pupil\u0026 s1, const pupil\u0026 s2) { if (s1.ac_t != s2.ac_t) { return s1.ac_t \u003e s2.ac_t; } else if (s1.time != s2.time) { return s1.time \u003c s2.time; } else { return s1.name \u003c s2.name; } } }; set \u003c pupil, rule \u003e s; void process(string a) { stringstream ssp(a); int num; ssp \u003e\u003e num; if (num \u003e 0) { ++total_ac; int i = a.size() - 1; int cnt_n = 0; if (a[i] == ')') { --i; for (int p = 1; a[i] != '('; --i, p *= 10) { cnt_n += a[i] * p - '0'; } } total_time += (cnt_n * litter + num); } return; } void input() { string st; while (getline(cin, st)) { if (st == \"\") { return; } stringstream ss(st); ss \u003e\u003e tmp.name; total_ac = 0; total_time = 0; for (int i = 1; i \u003c= cnt; ++i) { string a; ss \u003e\u003e a; process(a); } tmp.time = total_time; tmp.ac_t = total_ac; s.insert(tmp); } return; } void output() { set \u003c pupil, rule \u003e::iterator i = s.begin(); for (; i != s.end(); ++i) { cout \u003c\u003c std::left \u003c\u003c setw(10) \u003c\u003c (*i).name \u003c\u003c \" \" \u003c\u003c std::right \u003c\u003c setw(2) \u003c\u003c (*i).ac_t \u003c\u003c \" \" \u003c\u003c std::right \u003c\u003c setw(4) \u003c\u003c (*i).time \u003c\u003c endl; } return; } int main() { string absorb; cin \u003e\u003e cnt \u003e\u003e litter; getline(cin, absorb); input(); output(); return 0; }  ","date":"2020-12-16","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/495/:0:0","tags":["acm","C/C++","编程"],"title":"考试排名","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/495/"},{"categories":["C/C++"],"content":"题目描述 某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同： 1) 院士奖学金，每人8000元，期末平均成绩高于80分（80），并且在本学期内发表1篇或1篇以上论文的学生均可获得； 2) 五四奖学金，每人4000元，期末平均成绩高于85分（85），并且班级评议成绩高于80分（80）的学生均可获得； 3) 成绩优秀奖，每人2000元，期末平均成绩高于90分（90）的学生均可获得； 4) 西部奖学金，每人1000元，期末平均成绩高于85分（85）的西部省份学生均可获得； 5) 班级贡献奖，每人850元，班级评议成绩高于80分（80）的学生干部均可获得； 只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是87分，班级评议成绩82分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是4850元。 现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。 输入 输入的第一行是一个整数N（1 输出 输出包括三行，第一行是获得最多奖金的学生的姓名，第二行是这名学生获得的奖金总数。如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入文件中出现最早的学生的姓名。第三行是这N个学生获得的奖学金的总数。 #include\u003cbits/stdc++.h\u003e using namespace std; struct people{ char name[20],leader, western; short int end, comment, paper; }; void input(people\u0026 c) { cin \u003e\u003e c.name \u003e\u003e c.end \u003e\u003e c.comment \u003e\u003e c.leader \u003e\u003e c.western \u003e\u003e c.paper; } int main() { short int n; people x, y; int all = 0, max=0, sch; cin \u003e\u003e n; while (n--) { input(x); sch = 0; if (x.end \u003e 80 \u0026\u0026 x.paper \u003e 0) { sch = 8000; all = all + 8000; }//院士 if (x.end \u003e 85 \u0026\u0026 x.comment \u003e 80) { sch = sch + 4000; all = all + 4000; }//54 if (x.end \u003e 90) { sch = sch + 2000; all = all +2000; }//优秀 if (x.end \u003e 85 \u0026\u0026 x.western == 'Y') { sch = sch + 1000; all = all + 1000; }//西部 if (x.comment \u003e 80 \u0026\u0026 x.leader == 'Y') { sch = sch + 850; all = all + 850; }//班干 if (sch \u003e max) { max = sch; y = x; } } cout \u003c\u003c y.name \u003c\u003c endl \u003c\u003c max \u003c\u003c endl \u003c\u003c all; return 0; }  ","date":"2020-12-15","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/493/:0:0","tags":["acm","C/C++","编程"],"title":"谁拿了最多奖学金？","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/493/"},{"categories":["C/C++"],"content":"题目描述 从键盘读入n个复数（实部和虚部都为整数）用链表存储，遍历链表求出n个复数的和并输出。 #include\u003cbits/stdc++.h\u003e using namespace std; struct Complex { int real; int image; }; void input(Complex\u0026 c) { cin \u003e\u003e c.real \u003e\u003e c.image; } int main() { int n, x=0, y=0; Complex a, b,c; cin \u003e\u003e n; while (n--) { input(a); x = x + a.real; y = y + a.image; } cout \u003c\u003c x \u003c\u003c \"+\" \u003c\u003c y\u003c\u003c\"i\"; return 0; }  ","date":"2020-12-15","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/487/:0:0","tags":["acm","C/C++","编程"],"title":"复数求和","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/487/"},{"categories":["C/C++"],"content":"题目描述 数集拓展到实数范围内，仍有些运算无法进行。比如判别式小于0的一元二次方程仍无解，因此将数集再次扩充，达到复数范围。 定义：形如z=a+bi的数称为复数(complex number)，其中规定i为虚数单位，且i^2=i*i=-1（a，b是任意实数） 我们将复数z=a+bi中的实数a称为复数z的实部（real part)记作Rez=a 实数b称为复数z的虚部（imaginary part)记作 Imz=b. 已知：当b=0时，z=a，这时复数成为实数； 当a=0且b≠0时 ，z=bi，我们就将其称为纯虚数。 定义： 对于复数z=a+bi，称复数z’=a-bi为z的共轭复数。 定义：将复数的实部与虚部的平方和的正的平方根的值称为该复数的模，记作∣z∣ 规定复数的乘法按照以下的法则进行： 设z1=a+bi，z2=c+di(a、b、c、d∈R)是任意两个复数，那么它们的积(a+bi)(c+di)=(ac－bd)+(bc+ad)i. 其实就是把两个复数相乘，类似两个多项式相乘，在所得的结果中把i2换成－1，并且把实部与虚部分别合并.两个复数的积仍然是一个复数. 输入 两个复数分两行，每行两个数，代表复数的实部和虚部。 输出 两个复数的乘积。 #include\u003cbits/stdc++.h\u003e using namespace std; struct Complex { int real; int image; }; void input(Complex\u0026c) { cin\u003e\u003ec.real\u003e\u003ec.image; } void disp(Complex c) { cout\u003c\u003cc.real\u003c\u003c\" \"\u003c\u003cc.image; } Complex multi(Complex a,Complex b) { Complex c; c.real=a.real*b.real-a.image*b.image; c.image=a.real*b.image+a.image*b.real; return c; } int main() { Complex a,b; input(a); input(b); disp(multi(a,b)); return 0; }  ","date":"2020-12-14","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/485/:0:0","tags":["acm","C/C++","编程"],"title":"复数乘积","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/485/"},{"categories":["C/C++"],"content":"题目描述 给你2个分数，求他们的和，并要求和为最简形式。 ","date":"2020-12-11","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/483/:0:1","tags":["acm","C/C++","编程"],"title":"a/b+c/d","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/483/"},{"categories":["C/C++"],"content":"输入 输入首先包含一个正整数T（T\u003c=1000），表示有T组测试数据，然后是T行数据，每行包含四个正整数a,b,c,d（0\u003ca,b,c,d\u003c1000），表示两个分数a/b 和 c/d。 ","date":"2020-12-11","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/483/:0:2","tags":["acm","C/C++","编程"],"title":"a/b+c/d","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/483/"},{"categories":["C/C++"],"content":"输出 对于每组测试数据，输出两个整数e和f，表示a/b + c/d的最简化结果是e/f，每组输出占一行。 #include\u003cbits/stdc++.h\u003e using namespace std; int gcd(int a, int b) { if (b == 0)return a; else return gcd(b, a%b); } int main() { int n,a,b,c,d; cin \u003e\u003en; while (n--) { cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d; int x,y; x = a * d + b * c; y = b * d; int z = gcd(x,y); cout \u003c\u003c x/z \u003c\u003c \" \" \u003c\u003c y/z \u003c\u003c endl; } return 0; }  ","date":"2020-12-11","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/483/:0:3","tags":["acm","C/C++","编程"],"title":"a/b+c/d","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/483/"},{"categories":["C/C++"],"content":"题目描述 数集拓展到实数范围内，仍有些运算无法进行。比如判别式小于0的一元二次方程仍无解，因此将数集再次扩充，达到复数范围。 定义：形如z=a+bi的数称为复数(complex number) 其中规定i为虚数单位，且i^2=i*i=-1（a，b是任意实数） 我们将复数z=a+bi中的实数a称为复数z的实部（real part)记作Rez=a 实数b称为复数z的虚部（imaginary part)记作 Imz=b. 已知：当b=0时，z=a，这时复数成为实数； 当a=0且b≠0时 ，z=bi，我们就将其称为纯虚数。 定义： 对于复数z=a+bi，称复数z’=a-bi为z的共轭复数。 \u003cp\u003e \u003cb\u003e定义：将复数的实部与虚部的平方和的正的平方根的值称为该复数的模，记作∣z∣\u003c/b\u003e \u003c/p\u003e 即对于复数z=a+bi，它的模 ∣z∣=√(a^2+b^2) 复数的集合用C表示，显然，R是C的真子集 复数集是无序集，不能建立大小顺序。 共轭复数有些有趣的性质: ︱x+yi︱=︱x-yi︱ (x+yi)*(x-yi)=x^2+y^2=︱x+yi︱^2=︱x-yi︱^2 输入 两个复数分两行，每行两个整数r,i，代表复数的实部和虚部。|r,i|输出 两个复数的和。 #include\u003cbits/stdc++.h\u003e using namespace std; struct Complex { int real; int image; }; void input(Complex\u0026c) { cin\u003e\u003ec.real\u003e\u003ec.image; } void disp(Complex c) { cout\u003c\u003cc.real\u003c\u003c\" \"\u003c\u003cc.image; } Complex add(Complex a,Complex b) { Complex c; c.real=a.real+b.real; c.image=a.image+b.image; return c; } int main() { Complex a,b; input(a); input(b); disp(add(a,b)); return 0; }  ","date":"2020-12-11","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/478/:0:0","tags":["acm","C/C++","编程"],"title":"复数加法","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/478/"},{"categories":["C/C++"],"content":"题目描述 有10个学生，每个学生的数据包括学号、姓名、3门课程的成绩。读入这10个学生的数据，要求输出3门课程的总平均成绩，以及个人平均分最高的学生的数据（包括学号、姓名、3门课程成绩、平均分数）。 输入 共有10行，每行包含了一个学生的学号（整数）、名字（长度不超过19的无空格字符串）和3门课程的成绩（0至100之间的整数），用空格隔开。 输出 第一行包含了3个实数，分别表示3门课程的总平均成绩，保留2位小数，每个数之后输出一个空格。 第二行输出个人平均分最高的学生的数据，与输入数据格式相同。如果有多位个人平均分最高的学生，输出按照输入顺序第一个最高分的学生数据。 请注意行尾输出换行。 #include\u003cbits/stdc++.h\u003e using namespace std; struct { int num; string name; int g1;int g2; int g3; }info; int main() { double x1=0, x2=0, x3=0, p, q = 0; string j; int n = 10,i,k,l,m; while (n--){cin \u003e\u003e info.num \u003e\u003e info.name \u003e\u003e info.g1 \u003e\u003e info.g2 \u003e\u003e info.g3; x1 = x1 + info.g1; x2 = x2 + info.g2; x3 = x3 + info.g3; p = info.g1 + info.g2 + info.g3; if (p \u003e q) { q = p; i = info.num; j = info.name; k = info.g1; l = info.g2; m = info.g3; } } cout \u003c\u003c fixed \u003c\u003c setprecision(2) \u003c\u003c (x1 / 10)\u003c\u003c\" \" \u003c\u003c (x2 / 10)\u003c\u003c\" \" \u003c\u003c (x3 / 10) \u003c\u003c endl; cout \u003c\u003c i\u003c\u003c\" \"\u003c\u003cj\u003c\u003c\" \"\u003c\u003ck\u003c\u003c\" \"\u003c\u003cl\u003c\u003c\" \"\u003c\u003cm\u003c\u003c endl; return 0; }  ","date":"2020-12-10","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/472/:0:0","tags":["acm","C/C++","编程"],"title":"结构体计算学生成绩平均值","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/472/"},{"categories":["C/C++"],"content":"题目描述 编写两个函数input和print，分别用来输入5个学生的数据记录和打印这5个学生的记录。对于每一个学生，其记录包含了学号、名字、3门课程的成绩共5项。用主函数分别调用input和print函数进行输入和输出。 要求使用结构体数组实现，结构体中包括了每个学生的5项记录。 输入 共有5行，每行包含了一个学生的学号（整数）、名字（长度不超过19的无空格字符串）和3门课程的成绩（0至100之间的整数），用空格隔开。 输出 与输入格式相同，每行输出一个学生的所有记录。 请注意行尾输出换行。 #include\u003cbits/stdc++.h\u003e using namespace std; struct { int num; string name; int g1;int g2; int g3; }info; int main() { while (cin \u003e\u003e info.num \u003e\u003e info.name \u003e\u003e info.g1 \u003e\u003e info.g2 \u003e\u003e info.g3) { cout \u003c\u003c info.num \u003c\u003c \" \" \u003c\u003c info.name \u003c\u003c \" \" \u003c\u003c info.g1 \u003c\u003c \" \" \u003c\u003c info.g2 \u003c\u003c \" \" \u003c\u003c info.g3 \u003c\u003c endl; } return 0; }  ","date":"2020-12-09","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/467/:0:0","tags":["acm","C/C++","编程"],"title":"结构体输入与输出","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/467/"},{"categories":["C/C++"],"content":"题目描述 定义一个包括年、月、日的结构体变量，读入年、月、日，计算该日在当年中是第几天。注意闰年问题。 请写一个函数days实现计算，将读入的结构体变量传递给days函数，计算后将答案返回给main函数进行输出。 输入 三个整数，分别表示年、月、日。保证输入是实际存在的日期，且年份在1000至3000之间（包含1000和3000）。 输出 输出该日期是一年中的第几天。 请注意行尾输出换行。 #include\u003cbits/stdc++.h\u003e using namespace std; struct date { int y, m, d; inline bool leap() { return y % 4 == 0 \u0026\u0026 y % 100 != 0 || y % 400 == 0; } inline int getMonthDay(int m) { if (m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12)return 31; if (m == 4 || m == 6 || m == 9 || m == 11)return 30; if (leap())return 29; return 28; } }; int days(date d) { int ret = d.d; for (int i = 1; i \u003c d.m; i++) ret += d.getMonthDay(i); return ret; } int main() { date d; cin \u003e\u003e d.y \u003e\u003e d.m \u003e\u003e d.d; cout \u003c\u003c days(d) \u003c\u003c endl; return 0; }  ","date":"2020-12-09","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/464/:0:0","tags":["acm","C/C++","编程"],"title":"结构体计算天数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/464/"},{"categories":["C/C++"],"content":"题目描述 给定一段文章，请输出每个字母出现的次数 输入 只有一组输入数据，文件少于1000行。在文章中除最后一个字符外，只有大小写字母、空格和换行符，没有另外的标点、数字。该文章以’#’结尾。 输出 输出格式为“C A”，C为’a’..’z’中的字母，A为出现次数，C和A之间空一格 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { char r[1000],s[1000],c; int a[1000]; int n,i,j,t=0; for(i='a',j=0; i\u003c='z'; i++) { a[j]=0; s[j++]=i; } int flag=1; while(flag!=0\u0026\u0026gets(r)){ for(j=0; j\u003cstrlen(r); j++) { if(r[j]=='#') { flag=0; break; } for(i=0; i\u003c26; i++) { if(s[i]==r[j]||(r[j]+32)==s[i]) a[i]++; } } } for(i=0; i\u003c26; i++) { cout\u003c\u003cs[i]\u003c\u003c\" \"\u003c\u003ca[i]\u003c\u003cendl; } return 0; }   ","date":"2020-12-03","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/461/:0:0","tags":["acm","C/C++","编程"],"title":"统计字母个数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/461/"},{"categories":["C/C++"],"content":"题目描述 描述国王有一个魔镜，可以把任何接触镜面的东西变成原来的两倍——只是，因为是镜子嘛，增加的那部分是反的。 比如一条项链，我们用AB来表示，不同的字母表示不同颜色的珍珠。如果把B端接触镜面的话，魔镜会把这条项链变为ABBA。如果再用一端接触的话，则会变成ABBAABBA（假定国王只用项链的某一端接触魔镜）。 给定最终的项链，请编写程序输出国王没使用魔镜之前，最初的项链可能的最小长度。 输入 第一行是一个整数N(N输出 每组测试数据的输出只有一个整数，表示小H没有使用魔法前，最初的项链可能的最小长度。 #include\u003cbits/stdc++.h\u003e using namespace std; bool ok(char* w) { int n = strlen(w); if (n \u003c 2 || n \u0026 1)return false; char s[1000]; strcpy(s, w); reverse(s, s + n); return strcmp(s, w) == 0; } int main() { int T; cin \u003e\u003e T; char w[1000]; while (T--) { cin \u003e\u003e w; while (ok(w))w[strlen(w) / 2] = 0; cout \u003c\u003c strlen(w) \u003c\u003c endl; } return 0; }  ","date":"2020-12-03","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/459/:0:0","tags":["acm","C/C++","编程"],"title":"国王的魔镜","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/459/"},{"categories":["C/C++"],"content":"题目描述 对于输入的每个字符串，查找其中的最大字母，在该字母后面插入字符串“(max)”。 输入 输入数据包括多个测试实例，每个实例由一行长度不超过100的字符串组成，字符串仅由大小写字母及数字构成 输出 对于每个测试实例输出一行字符串，输出的结果是插入字符串“(max)”后的结果，如果存在多个最大的字母，就在每一个最大字母后面都插入”(max)”。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { char s[100 + 10]; while (cin \u003e\u003e s) { for (char* p = s; *p; ++p) { char m = *max_element(s, s + strlen(s)); cout \u003c\u003c *p; if (*p == m)cout \u003c\u003c \"(max)\"; } cout \u003c\u003c endl; } return 0; }   ","date":"2020-12-03","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/457/:0:0","tags":["acm","C/C++","编程"],"title":"查找最大元素","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/457/"},{"categories":["C/C++"],"content":"题目描述 回文串是从左到右或者从右到左读起来都一样的字符串，试编程判别一个字符串是否为回文串。是则输出Y，不是则输出N 输入 多组输入,每组输入一个不含有空格的字符串。题目保证串长度 不超过255. 输出 判别输入的字符串是否为回文串，是输出”Y”,否则输出”N”。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { char s[255 + 10], t[255 + 10]; while (cin \u003e\u003e s) { strcpy(t, s); reverse(t, t + strlen(t)); if (strcmp(s, t) == 0)cout \u003c\u003c \"Y\" \u003c\u003c endl; else cout \u003c\u003c \"N\" \u003c\u003c endl; } return 0; }  ","date":"2020-12-03","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/455/:0:0","tags":["acm","C/C++","编程"],"title":"回文串","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/455/"},{"categories":["C/C++"],"content":"题目描述 现在给出了一个只包含大小写字母的字符串，不含空格和换行，要求把其中的大写换成小写，小写换成大写，然后输出互换后的字符串。 输入 第一行只有一个整数m（m输出 输出互换后的字符串，每组输出占一行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n, i, j; cin \u003e\u003e n; string a; while (n--) { cin \u003e\u003e a; j = a.length(); for (i = 0; i \u003c j; i++) { if (a[i] \u003e= 'a' \u0026\u0026 a[i] \u003c= 'z')a[i] = a[i] - 32; else a[i] += 32; } cout \u003c\u003c a \u003c\u003c endl; } return 0; }  ","date":"2020-12-03","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/453/:0:0","tags":["acm","C/C++","编程"],"title":"字母大小写转换","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/453/"},{"categories":["C/C++"],"content":"题目描述 输入三个字符（可以重复）后，按各字符的ASCII码从小到大的顺序输出这三个字符。 输入 第一行输入一个数N,表示有N组测试数据。后面的N行输入多组数据，每组输入数据都是占一行，有三个字符组成，之间无空格。 输出 对于每组输入数据，输出一行，字符中间用一个空格分开。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n; cin \u003e\u003e n; const char* a[3],*b; string t, x, y, z; while (n--) { cin \u003e\u003e t; x = t[0]; y = t[1]; z = t[2]; a[0] = x.c_str(); a[1] = y.c_str(); a[2] = z.c_str(); if (strcmp(a[0], a[1]) \u003e 0) { b = a[0]; a[0] = a[1]; a[1] = b; } if (strcmp(a[0], a[2]) \u003e 0) { b = a[0]; a[0] = a[2]; a[2] = b; } if (strcmp(a[1], a[2]) \u003e 0) { b = a[1]; a[1] = a[2]; a[2] = b; } cout \u003c\u003c a[0] \u003c\u003c \" \" \u003c\u003c a[1] \u003c\u003c \" \" \u003c\u003c a[2] \u003c\u003c endl; } return 0; }  ","date":"2020-12-03","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/451/:0:0","tags":["acm","C/C++","编程"],"title":"ASCII码给字母排序","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/451/"},{"categories":["C/C++"],"content":"题目描述 小明最近多位数加法运算学的很晕倒：（，幸好是做判断题，它只需要判断A+B最后一位数是否是C就可以了，可是他真的懒的厉害，这不让你写一个程序帮助他 输入 两个长度不超过100位整数A B 一个个位数C 输出 正确与否,正确是YES 错误则输出NO #include\u003cbits/stdc++.h\u003e using namespace std; int main() { string a, b,a1,b1; int c,aa,bb; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; a1 = a[0]; b1 = b[0]; //取第一位 aa = atoi(a1.c_str()); //转换为整形 bb = atoi(b1.c_str()); if ((aa + bb)%10 == c)cout \u003c\u003c \"YES\"; else cout \u003c\u003c \"NO\"; return 0; }  ","date":"2020-12-03","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/449/:0:0","tags":["acm","C/C++","编程"],"title":"小明A+B(2)","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/449/"},{"categories":["C/C++"],"content":"题目描述 最近Kingly对编码很感兴趣，于是从网上找了一些编码原则来对字符串做实验。因为Kingly一直很忙，所以希望你这位编程高手来替他解决这个问题。下面是编码原则：（1） 如果访问到字符A，W，F就转化成I；（2） 如果访问到字符C，M，S就分别转化成L，o，v；（3） 如果访问到字符D，P，G，B就转化成e；（4） 如果访问到字符L，X就分别转化成Y，u；（5） 其他字符均保持不变；（6） 遇到END就结束！ #include\u003cbits/stdc++.h\u003e using namespace std; int main(void) { string a; int b, i; while (getline(cin, a)) { b = a.length(); for (i = 0; i \u003c b; i++) { if (a[i] == 'E' \u0026\u0026 a[i + 1] == 'N' \u0026\u0026 a[i + 2] == 'D')return 0; else if (a[i] == 'A' || a[i] == 'W' || a[i] == 'F')cout \u003c\u003c \"I\"; else if (a[i] == 'C')cout \u003c\u003c \"L\"; else if (a[i] == 'M')cout \u003c\u003c \"o\"; else if (a[i] == 'S')cout \u003c\u003c \"v\"; else if (a[i] == 'D' || a[i] == 'P' || a[i] == 'G' || a[i] == 'B')cout \u003c\u003c \"e\"; else if (a[i] == 'L')cout \u003c\u003c \"Y\"; else if (a[i] == 'X')cout \u003c\u003c \"u\"; else cout \u003c\u003c a[i]; }cout \u003c\u003c endl; } return 0; }  ","date":"2020-12-01","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/442/:0:0","tags":["acm","C/C++","编程"],"title":"简单编码","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/442/"},{"categories":["C/C++"],"content":"题目描述 读入一些字符串，将其中的小写字母转成大写字母（其他字符不变）。 输入 输入为多行，每行为一个字符串，字符串只由字母和数字组成，长度不超过80。 输出 对于每行输入，输出转换后的字符串。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { string a; int b, i; while (cin \u003e\u003e a) { b = a.length(); for (i = 0; i \u003c b; i++) { if (a[i] \u003e= 'a' \u0026\u0026 a[i] \u003c= 'z') { a[i] = a[i] - 32; } } cout \u003c\u003c a \u003c\u003c endl; } return 0; }  ","date":"2020-11-30","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/439/:0:0","tags":["acm","C/C++","编程"],"title":"字母小写转大写","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/439/"},{"categories":["C/C++"],"content":"题目描述 给定一个正整数n(１＜＝ｎ＜＝２０)，画出螺旋矩阵。 输入 一个正整数n 输出 对应画出螺旋矩阵 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 21; int a[maxn][maxn]; int n; void show() { for (int x = 0; x \u003c n; x++) { for (int y = 0; y \u003c n; y++) { cout \u003c\u003c a[x][y] \u003c\u003c \" \"; } cout \u003c\u003c endl; } } void cal() { int x = 0, y = 0; a[x][y] = 1; for (int k = 2; k \u003c= n * n; ) { while (1) { int nx = x, ny = y + 1; if (nx \u003c 0 || nx \u003e= n || ny \u003c 0 || ny \u003e= n || a[nx][ny]) { break; } a[x = nx][y = ny] = k++; } while (1) { int nx = x + 1, ny = y; if (nx \u003c 0 || nx \u003e= n || ny \u003c 0 || ny \u003e= n || a[nx][ny]) { break; } a[x = nx][y = ny] = k++; } while (1) { int nx = x, ny = y - 1; if (nx \u003c 0 || nx \u003e= n || ny \u003c 0 || ny \u003e= n || a[nx][ny]) { break; } a[x = nx][y = ny] = k++; } while (1) { int nx = x - 1, ny = y; if (nx \u003c 0 || nx \u003e= n || ny \u003c 0 || ny \u003e= n || a[nx][ny]) { break; } a[x = nx][y = ny] = k++; } } } int main() { cin \u003e\u003e n; cal(); show(); return 0; }  ","date":"2020-11-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/432/:0:0","tags":["acm","C/C++","编程"],"title":"螺旋矩阵","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/432/"},{"categories":["C/C++"],"content":"题目描述 求矩阵的两对角线上的元素之和 输入 矩阵的行数N 和一个N∗N\"N∗N的整数矩阵ai,j1≤N≤10\"ai,j1≤N≤10每一个元素都是整数，范围[-100,100] 输出 所输矩阵的两对角线上的元素之和 #include\u003cbits/stdc++.h\u003e using namespace std; int a[100][100]; int n, x, y, sum = 0; int main() { cin \u003e\u003e n; for (x = 0; x \u003c n; x++) { for (y = 0; y \u003c n; y++) { cin \u003e\u003e a[x][y]; } } for (x = 0; x \u003c n; x++) { for (y = 0; y \u003c n; y++) { if (x + y == n - 1 || x == y) { sum += a[x][y]; } } } cout \u003c\u003c sum; return 0; }  ","date":"2020-11-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/430/:0:0","tags":["acm","C/C++","编程"],"title":"求矩阵两对角线上的元素之和","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/430/"},{"categories":["C/C++"],"content":"题目描述 Apple最近迷上了做幻方，Apple还是个中高手，只要你说个奇数N就能把N*N的幻方做出来。其实你可以比他做得更好的。Apple总是画得很乱，而你可以利用程序排得很整齐^_^ 幻方的要求：每一行，每一列，还有两条斜线上数字的和都相等. 输入 每行一个奇数N(0输出 输入一个奇数，输出一个幻方，顺序参照样板输出；数与数用一个空格分开；输出完以后加一个回车。 #include\u003cbits/stdc++.h\u003e using namespace std; int a[100][100]; int n; void show() { for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { cout \u003c\u003c a[i][j] \u003c\u003c \" \"; } cout \u003c\u003c endl; } } void cal() { memset(a, 0, sizeof(a)); int x = n - 1, y = n / 2; a[x][y] = 1; for (int k = 2; k \u003c= n * n; k++) { int nx = (x + 1) % n; int ny = (y + 1) % n; if (a[nx][ny] != 0) { nx = (x - 1 + n) % n; ny = y; } a[nx][ny] = k; x = nx; y = ny; } } int main() { while (cin \u003e\u003e n) { cal(); show(); cout \u003c\u003c endl; } return 0; }   ","date":"2020-11-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/427/:0:0","tags":["acm","C/C++","编程"],"title":"做幻方","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/427/"},{"categories":["C/C++"],"content":"题目描述 输出一个回形方阵，具体可见样例 输入 一个整数n （0 ＜ n ＜ 10） 输出 一个方阵，每个数字的定宽为2 提示 实现定宽为2：C语言用printf(\"%2d\",x); C++用cout\u003c\u003csetw(2)\u003c\u003cx; #include \u003cbits/stdc++.h\u003e using namespace std; int a[100][100]; int n, size; void input() { cin \u003e\u003e n; } void cal() { size = 2 * n + 1; for (int j = 0; j \u003c size; j++) { for (int i = 0; i \u003c size; i++) { a[i][j] = max(abs(i - n), abs(j - n)); } } } void show() { for (int i = 0; i \u003c size; i++) { for (int j = 0; j \u003c size; j++) { cout \u003c\u003c \" \" \u003c\u003c a[i][j]; } cout \u003c\u003c endl; } } int main() { input(); cal(); show(); return 0; }   ","date":"2020-11-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/423/:0:0","tags":["acm","C/C++","编程"],"title":"回形方阵","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/423/"},{"categories":["C/C++"],"content":"题目描述 扫雷是一个经典的游戏，在一个N*M区域中 输入一个N*M的雷区中的k个雷坐标，打印出所有雷区的分布 一个位置如果是雷则表示为*,否则应该是0~8，表示他周围八连通域中的地雷总数。 输入 雷区尺寸 3=输出 雷区的分布 每组后空一行 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 21; const int BOMB = 999; int a[maxn][maxn]; int m, n, k, x, y; void show() { for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c m; j++) { if (a[i][j] != BOMB) { cout \u003c\u003c a[i][j]; } else { cout \u003c\u003c \"*\"; } } cout \u003c\u003c endl; } } void cal() { for (x = 0; x \u003c n; x++) for (y = 0; y \u003c m; y++) { if (a[x][y] == BOMB) { continue; } int\u0026 tot = a[x][y]; for (int dx = -1; dx \u003c= 1; ++dx) for (int dy = -1; dy \u003c= 1; ++dy) { if (dx == 0 \u0026\u0026 dy == 0) { continue; } int nx = x + dx; int ny = y + dy; if (nx \u003c 0 || nx \u003e= n || ny \u003c 0 || ny \u003e= m) { continue; } if (a[nx][ny] == BOMB) { ++tot; } } } } void input() { memset(a, 0, sizeof(a)); while (k--) { cin \u003e\u003e x \u003e\u003e y; a[x][y] = BOMB; } } int main() { while (cin \u003e\u003e n \u003e\u003e m \u003e\u003e k) { input(); cal(); show(); cout \u003c\u003c endl; } return 0; }  ","date":"2020-11-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/421/:0:0","tags":["acm","C/C++"],"title":"扫雷","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/421/"},{"categories":["C/C++"],"content":"题目描述 按要求输入如下格式的杨辉三角 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 最多输出10层 输入 输入只包含一个正整数n，表示将要输出的杨辉三角的层数。 输出 对应于该输入，请输出相应层数的杨辉三角，每一层的整数之间用一个空格隔开 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int i,j,n,a[10][10]; cin\u003e\u003en; for(int t=0;t\u003cn;t++){ a[t][0]=1;a[t][t]=1; } for(i=2;i\u003cn;i++){ for(j=1;j\u003ci;j++){ a[i][j]=a[i-1][j]+a[i-1][j-1]; } } for(i=0;i\u003cn;i++){ for(j=0;j\u003c=i;j++){ cout\u003c\u003ca[i][j]\u003c\u003c\" \"; } cout\u003c\u003cendl; } return 0; }  ","date":"2020-11-27","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/415/:0:0","tags":["acm","C/C++","编程"],"title":"杨辉三角","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/415/"},{"categories":["未分类"],"content":"#include\u003cbits/stdc++.h\u003e using namespace std; int f(int t){ if(t\u003c4)return 1; return f(t-3)+f(t-1); } int main(){ int n; cin\u003e\u003en; cout\u003c\u003cf(n)\u003c\u003cendl; return 0; }  ","date":"2020-11-23","objectID":"/2020/uncategorized/409/:0:0","tags":null,"title":"","uri":"/2020/uncategorized/409/"},{"categories":["C/C++"],"content":"数组解法 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n[3],i; for(i=0;i\u003c3;i++){ cin\u003e\u003en[i]; } cout\u003c\u003c(*max_element(n, n + 3)); }  ","date":"2020-11-20","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/391/:0:0","tags":["acm","C/C++","编程"],"title":"三个数求最大值","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/391/"},{"categories":["C/C++"],"content":"题目描述 Finding Missing Cards Taro is going to play a card game. However, now he has only n cards, even though there should be 52 cards (he has no Jokers). The 52 cards include 13 ranks of each of the four suits: spade, heart, club and diamond. 输入 In the first line, the number of cards n (n ≤ 52) is given. In the following n lines, data of the n cards are given. Each card is given by a pair of a character and an integer which represent its suit and rank respectively. A suit is represented by ‘S’, ‘H’, ‘C’ and ‘D’ for spades, hearts, clubs and diamonds respectively. A rank is represented by an integer from 1 to 13. 输出 Print the missing cards. The same as the input format, each card should be printed with a character and an integer separated by a space character in a line. Arrange the missing cards in the following priorities: Print cards of spades, hearts, clubs and diamonds in this order. If the ranks are equal, print cards with lower ranks first. #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; int s[13],h[13],c[13],d[13]; int ss=0,hh=0,cc=0,dd=0; char t; cin\u003e\u003en; while(n--){ cin\u003e\u003et; switch(t){ case 'S' : cin\u003e\u003es[ss]; ss++; break; case 'H' : cin\u003e\u003eh[hh]; hh++; break; case 'C' : cin\u003e\u003ec[cc]; cc++; break; case 'D' : cin\u003e\u003ed[dd]; dd++; break; } } sort(s,s+ss); sort(h,h+hh); sort(c,c+cc); sort(d,d+dd); for (int i = 1, j = 0; i \u003c= 13; i++) { if (s[j] != i) cout \u003c\u003c \"S \" \u003c\u003c i \u003c\u003c endl; else ++j; } for (int i = 1, j = 0; i \u003c= 13; i++) { if (h[j] != i) cout \u003c\u003c \"H \" \u003c\u003c i \u003c\u003c endl; else ++j; } for (int i = 1, j = 0; i \u003c= 13; i++) { if (c[j] != i) cout \u003c\u003c \"C \" \u003c\u003c i \u003c\u003c endl; else ++j; } for (int i = 1, j = 0; i \u003c= 13; i++) { if (d[j] != i) cout \u003c\u003c \"D \" \u003c\u003c i \u003c\u003c endl; else ++j; } return 0; }  ","date":"2020-11-18","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/386/:0:0","tags":["acm","C/C++","编程"],"title":"数组计算缺失的扑克牌Array – Finding Missing Cards","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/386/"},{"categories":["C/C++"],"content":"将n换成求的位数 3位数比大小就是 n=3; 以此类推 升序 降序只留一个 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n=3; //求几个数n就等于几 int a[n]; int i,j,t; for(i=0; i\u003cn; i++){ cin\u003e\u003ea[i];} sort(a,a+n); //升序 sort(a,a+n,greater\u003cint\u003e()); //降序 for(i=0; i\u003cn; i++){ cout\u003c\u003ca[i]\u003c\u003c' ';} return 0; } ","date":"2020-11-17","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/384/:0:0","tags":["acm","C/C++","编程"],"title":"整数排序模板","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/384/"},{"categories":["C/C++"],"content":"题目描述 将一个长度为10的整型数组中的值按逆序重新存放。 如：原来的顺序为1,2,3,4,5,6,7,8,9,0，要求改为0,9,8,7,6,5,4,3,2,1 输入 从键盘上输入以空格分隔的10个整数。 输出 按相反的顺序输出这10个数，每个数占一行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a[10]; int i; for(i=0;i\u003c10;i++){ scanf(\"%d\",\u0026a[i]); } for(i=9;i\u003e=0;i--){ printf(\"%d \",a[i]); } return 0; }   ","date":"2020-11-16","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/378/:0:0","tags":["acm","C/C++","编程"],"title":"输出倒序数组（数组元素逆置）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/378/"},{"categories":["C/C++"],"content":"题目描述 Fibonacci数列的特点：第1,2个数为1,1。从第3个数开始，概述是前面两个数之和。即： 要求输出Fibonacci数列的前20个数。 输入 无 输出 Fibonacci数列的前20个数，每个数占一行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int f[20]={1,1}; for(int n=2;n\u003c20;n++){ f[n]=f[n-1]+f[n-2]; } for(int i=0;i\u003c20;i++){ cout\u003c\u003cf[i]\u003c\u003cendl; } return 0; }  ","date":"2020-11-16","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/374/:0:0","tags":["acm","C/C++","编程"],"title":"Fibonacci数列前20项(斐波那契数列)","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/374/"},{"categories":["C/C++"],"content":"题目描述 从键盘上输入10个整数，用冒泡法对这10个数进行排序（由小到大）。 输入 以空格分隔的10个整数 输出 依次输出排好序的10个整数，每个数占一行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a[10]; int i,j,t; for(i=0; i\u003c10; i++) scanf(\"%d\",\u0026a[i]); for(j=0; j\u003c9; j++) for(i=0; i\u003c9-j; i++) if(a[i]\u003ea[i+1]) { t=a[i]; a[i]=a[i+1]; a[i+1]=t; } for(i=0; i\u003c10; i++) printf(\"%d \",a[i]); }  ","date":"2020-11-16","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/372/:0:0","tags":["acm","C/C++","编程"],"title":"冒泡排序","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/372/"},{"categories":["C/C++"],"content":"题目描述 著名的哥德巴赫猜想可以陈述为：任何一个不小于6的偶数一定可以拆成两个质数的和。如6=3+3,8=5+3等，你的任务是将一个大于6的偶数n拆成两个最接近的质数p,q,满足p+q=n. 输入 输入包含多组测试数据。每组数据包含1个偶数n（n在6到1000000之间包含边界）。 输出 对于每组测试数据，输出两个质数p,q(p#include\u003ciostream\u003e using namespace std; int P[1000000]={0}; void Prime_list() { P[0]=P[1]=1; for(int i=2;i\u003c1000000;i++) { for(int j=i*2;j\u003c1000000;j+=i) P[j]=1; } } main() { int n; int i,cache; Prime_list(); while(cin\u003e\u003en) { for(i=2;i\u003c=n/2;i++) { if(P[i]==0\u0026\u0026P[n-i]==0) {cache=i;} } cout\u003c\u003ccache\u003c\u003c\" \"\u003c\u003cn-cache\u003c\u003cendl; } }  ","date":"2020-11-15","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/369/:0:0","tags":["acm","C/C++","编程"],"title":"哥德巴赫猜想","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/369/"},{"categories":["C/C++"],"content":"题目描述 输入两个点的坐标，即p1 = (x1, y1)和p2=(x2, y2)，求过这两个点的直线的斜率。如果斜率为无穷大输出“INF”。 #include\u003cbits/stdc++.h\u003e using namespace std; int slope(int x1,int y1,int x2,int y2){ return (y2-y1)/(x2-x1); } int main(){ int x1,y1,x2,y2,t; while(scanf(\"%d %d %d %d\",\u0026x1,\u0026y1,\u0026x2,\u0026y2)!=EOF){ if(x1==x2){ cout\u003c\u003c\"INF\"\u003c\u003cendl;continue; } if(y1==y2){ cout\u003c\u003c\"0\"\u003c\u003cendl;continue; } cout\u003c\u003cslope(x1,y1,x2,y2)\u003c\u003cendl; } return 0; }  ","date":"2020-11-14","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/364/:0:0","tags":["acm","C/C++","编程"],"title":"斜率计算","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/364/"},{"categories":["C/C++"],"content":"题目描述 编写一个函数，输入一行字符，将此字符串中最长的单词输出。 输入仅一行，多个单词，每个单词间用一个空格隔开。单词仅由小写字母组成。所有单词的长度和不超过100000。如有多个最长单词，输出最先出现的。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ char a[100000],b[100000]; int aa,bb; scanf(\"%s\",\u0026a); strcpy(b,a); while(scanf(\"%s\",\u0026a)!=EOF){ aa=strlen(a);bb=strlen(b); if(aa\u003ebb){ strcpy(b,a); } } printf(\"%s\",b); return 0; }   ","date":"2020-11-14","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/361/:0:0","tags":["acm","C/C++","编程"],"title":"最长单词（输出最长字符串）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/361/"},{"categories":["C/C++"],"content":"题目描述 输入一个整数n\"n（1≤n≤263−1\"1≤n≤263−1），你的任务是算出n\"nn最高位 输入 多组输入，第一个是整数N\"N代表有N\"N个数， 后面有N\"N个整数m\"m 对每一个m\"m输出最高一位 输出 对每一个m\"m输出最高一位 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ char n[20]; int x,i; cin\u003e\u003ei; while(i--){ scanf(\"%s\",n); cout\u003c\u003cn[0]\u003c\u003cendl; } return 0; }   ","date":"2020-11-13","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/356/:0:0","tags":["acm","C/C++","编程"],"title":"求（超大）数字的第一位","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/356/"},{"categories":["C/C++"],"content":"题目描述 小王对既是素数又是回文的数特别感兴趣。比如说151既是素数又是个回文。现在小王想要你帮助他找出某个范围内的素数回文数，请你写个程序找出 a 跟b 之间满足条件的数。(5 输入 输入a和b(5 模块法 #include\u003cbits/stdc++.h\u003e using namespace std; bool primer(int n){ //定义布尔函数：判断素数（primer） if(n==2)return true; //n为2时返回 真 if(n\u003c2||n%2==0)return false;//n小于2或n为偶数返回 假 for(int c=3;c*c\u003c=n;c+=2){ //n有因数返回 假 if(n%c==0)return false; } return true; //不是上面的情况返回 真 } int reverse(int n){ //将数字反转 int m=0; while(n\u003e0){ m=m*10+n%10; n/=10; } return m; } bool sysmetric(int n){ //判断回文数（引用上面“数字反转”函数，当反转数字与原数字相同时为回文数） return n==reverse(n); } int main(){ int a,b; cin\u003e\u003ea\u003e\u003eb; for(int x=a;x\u003c=b;x++){ if(primer(x)\u0026\u0026sysmetric(x)){ //引用函数，当输入的数字都符合条件时会返回真 cout\u003c\u003cx\u003c\u003cendl; //当两个函数都返回真时，if语句才会被执行 } } return 0; }   暴力法 #define _CRT_SECURE_NO_WARNINGS #include\u003cbits/stdc++.h\u003e using namespace std; int huiwen(int z) { int j,i,n; char a[9],b[9]; sprintf(a,\"%d\",z); n=strlen(a); for(i=0,j=n-1;i\u003cn;i++,j--) b[j]=a[i]; for(i=0;i\u003cn;i++) { if(b[i]!=a[i]) break; } if(i==n)return z; else return 0; return 0; } int main(){ int x,y; int n,a=0; int i=1; int h; while(scanf(\"%d %d\",\u0026x,\u0026y)!=EOF){ n=x; while(n\u003c=y){ for(;n\u003ei;i++){ if(n%i==0){ a++; } } if(a==1){ h=huiwen(n); if(h!=0){ cout\u003c\u003cn\u003c\u003cendl; } } n++;i=1;a=0; } } return 0; }  ","date":"2020-11-13","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/354/:0:0","tags":["acm","C/C++","编程"],"title":"输出回文素数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/354/"},{"categories":["C/C++"],"content":"题目描述 如果一个整数可以写成另一个整数的平方，则说它是一个完全平方数。比如1,4,9,16\"1,4,9,16是完全平方数。 输入一个整数，找到一个离它最近的完全平方数。 输入 仅有一组测式数据，输入一个整数N\"NN, 0≤N≤100000\"≤N≤100000。 输出 输出离它最近的完全平方数,如果N\"N就是完全平方数，则输出N\"N。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,a=1,b,c,nn; cin\u003e\u003en; b=n; c=n; while(a*a!=b){ while(a*a\u003cb){ a++; } if(a*a!=b){ a=1; b--; } } while(a*a!=c){ while(a*a\u003cc){ a++; } if(a*a!=c){ a=1; c++; } } if((c-n)\u003e(n-b)){cout\u003c\u003cb;} else{cout\u003c\u003cc;} return 0; }  ","date":"2020-11-12","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/347/:0:0","tags":["acm","C/C++","编程"],"title":"最近平方数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/347/"},{"categories":["C/C++"],"content":"题目描述 组合数Cnr(n,r)=n!/r!/(n-r)!,虽然组合数的计算简单但也不乏有些陷阱，这主要是因为语言中的数据类型在表示范围上是有限的。更何况还有中间结果溢出的现象，所以千万要小心。 输入 输入数据不超过100多组测试用例，每一行有两个整数M与N，你可以假设结果不会超过64位有符号整数，每对整数M和N满足0=＜m, n≤28，以EOF结束。 输出 输出该组合数。每个组合数换行。 #define _CRT_SECURE_NO_WARNINGS #include\u003cbits/stdc++.h\u003e using namespace std; int main() { double m, n, nn; long double s = 1; while (scanf(\"%lf %lf\", \u0026m, \u0026n) != EOF) { nn = n; while (nn--) { s = s * m; m--; } nn = 1; while (n \u003e= nn) { s = s / nn; nn++; } printf(\"%.0Lf\\n\", s); s = 1; } return 0; }  ","date":"2020-11-12","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/345/:0:0","tags":["acm","C/C++","编程"],"title":"求组合数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/345/"},{"categories":["C/C++"],"content":"题目描述 写一个函数，给定年、月、日，计算该日期是该年的第几天。在主函数中输入一个日期（含年、月、日），通过函数调用，得到该日期所对应这一年的第几天，并输出该数值。 输入 三个以空格分隔的整数，分别表示该日期的年、月、日。 输出 输入日期所对应这一年的第几天，一个整数，单独占一行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int y,m,s,d=0; cin\u003e\u003ey\u003e\u003em\u003e\u003es; switch(m){ case 12 : d=d+30; m=m-1; case 11: d=d+31; m=m-1; case 10 : d=d+30; m=m-1; case 9 : d=d+31; m=m-1; case 8 : d=d+31; m=m-1; case 7 : d=d+30; m=m-1; case 6 : d=d+31; m=m-1; case 5 : d=d+30; m=m-1; case 4 : d=d+31; m=m-1; case 3 : if((y%4!=0)||(y%100==0\u0026\u0026y%400!=0)){ d=d+28; m=m-1; } else{ d=d+29; m=m-1; } case 2 : d=d+31; m=m-1; case 1 : break; } d=d+s; cout\u003c\u003cd; return 0; }  ","date":"2020-11-12","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/343/:0:0","tags":["acm","C/C++","编程"],"title":"日期计算","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/343/"},{"categories":["C/C++"],"content":"题目描述 写一个函数求两个整数的最小公倍数，通过主函数调用这个函数，并输出结果。 两个整数由键盘输入。 输入 以空格分隔的两个整数 输出 输入两数的最小公倍数，单独占一行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int x,y,n=1; cin\u003e\u003ex\u003e\u003ey; while(n%x!=0||n%y!=0){ n++; } cout\u003c\u003cn; return 0; }   ","date":"2020-11-12","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/341/:0:0","tags":["acm","C/C++","编程"],"title":"求最小公倍数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/341/"},{"categories":["C/C++"],"content":"题目描述 输入一个不多于5位的正整数，按逆序输出各位上的数字，末尾换行。 注意：确保输入的正整数的位数不多于5。 输入 一个不多于5位的正整数。 输出 逆序输出各位上的数字，中间以空格分隔。 注意末尾的换行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int x,t; cin\u003e\u003ex; while(x!=0){ t=x; cout\u003c\u003ct%10\u003c\u003c\" \"; x=x/10; } return 0; }   ","date":"2020-11-12","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/339/:0:0","tags":["acm","C/C++","编程"],"title":"逆序输出正整数各位上数字","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/339/"},{"categories":["C/C++"],"content":"题目描述 输入一个不多于5位的正整数，按高位到低位的顺序输出各位上的数字，末尾换行。 注意：确保输入的正整数的位数不多于5。 输入 一个不多于5位的正整数 输出 从高位到低位依次输出各位上的数字，中间以空格分隔的。 注意末尾的换行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int x,t; cin\u003e\u003ex; if(x\u003e9999){ t=x; t=t/10000; cout\u003c\u003ct\u003c\u003c\" \"; x=x%10000; } if(x\u003e999\u0026\u0026x\u003c=9999){ t=x; t=t/1000; cout\u003c\u003ct\u003c\u003c\" \"; x=x%1000; } if(x\u003e99\u0026\u0026x\u003c=999){ t=x; t=t/100; cout\u003c\u003ct\u003c\u003c\" \"; x=x%100; } if(x\u003e9\u0026\u0026x\u003c=99){ t=x; t=t/10; cout\u003c\u003ct\u003c\u003c\" \"; x=x%10; } cout\u003c\u003cx\u003c\u003cendl; return 0; }   ","date":"2020-11-12","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/337/:0:0","tags":["acm","C/C++","编程"],"title":"求正整数各位上的数字","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/337/"},{"categories":["C/C++"],"content":"题目描述 给定一个不多于5位的正整数，判断它是几位数，并将该数字输出。输出结束后换行。 注意：输入的数字要确保是一个不多于5位的正整数。 输入 一个不多于5位的正整数。 输出 输入正整数的位数，注意末尾的换行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int x,i; while(scanf(\"%d\",\u0026x)!=EOF){ while(x!=0){ x=x/10; i=i+1; } cout\u003c\u003ci\u003c\u003cendl; } return 0; }  ","date":"2020-11-12","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/334/:0:0","tags":["acm","C/C++","编程"],"title":"判断正整数位数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/334/"},{"categories":["C/C++"],"content":"题目描述 企业发放的奖金根据利润提成。利润低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元 时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万元到60万元 之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%；高于100万元时，超过100万元的部分按1%提成。 ","date":"2020-11-09","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/324/:1:0","tags":["acm","C/C++","编程"],"title":"奖金发放","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/324/"},{"categories":["C/C++"],"content":"输入 当月利润 ","date":"2020-11-09","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/324/:2:0","tags":["acm","C/C++","编程"],"title":"奖金发放","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/324/"},{"categories":["C/C++"],"content":"输出 当月奖金总数（保留两位小数，利润的大小在double以内） #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ double w=0,p; int x; while(scanf(\"%lf\",\u0026p)!=EOF){ if(p\u003e1000000){ x=1;} if(p\u003e600000\u0026\u0026p\u003c=1000000){x=2;} if(p\u003e400000\u0026\u0026p\u003c=600000){x=3;} if(p\u003e200000\u0026\u0026p\u003c=400000){x=4;} if(p\u003e100000\u0026\u0026p\u003c=200000){x=5;} if(p\u003c=100000){x=6;} switch(x){ case 1 : w=(p-1000000)*0.01+w; p=1000000; case 2 : w=(p-600000)*0.015+w; p=600000; case 3 : w=(p-400000)*0.03+w; p=400000; case 4 : w=(p-200000)*0.05+w; p=200000; case 5 : w=(p-100000)*0.075+w; p=100000; case 6 : w=p*0.1+w; p=0; } printf(\"%.2lf\\n\",w);} return 0; }  ","date":"2020-11-09","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/324/:3:0","tags":["acm","C/C++","编程"],"title":"奖金发放","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/324/"},{"categories":["C/C++"],"content":"问题描述 对一个数十进制表示时的每一位数字乘五次方再求和，会得到一个数的五次方数 例如：1024的五次方数为1+0+32+1024=1057 有这样一些神奇的数，它的五次方数就是它自己，而且这样的数竟然只有有限多个 从小到大输出所有这样的数 ","date":"2020-11-09","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/322/:1:0","tags":["acm","C/C++","编程"],"title":"五次方数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/322/"},{"categories":["C/C++"],"content":"输入 无 ","date":"2020-11-09","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/322/:2:0","tags":["acm","C/C++","编程"],"title":"五次方数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/322/"},{"categories":["C/C++"],"content":"输出 每个数独立一行输出 #include \u003ciostream\u003e using namespace std; int n; int wucifang(int x){ return x*x*x*x*x; } int main() { for(int i=2;i\u003c=194980;i++){ int sum=0,t=i; while(t){ sum+=wucifang(t%10); t/=10; } if(sum==i) cout\u003c\u003ci\u003c\u003cendl; } return 0; }  ","date":"2020-11-09","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/322/:3:0","tags":["acm","C/C++","编程"],"title":"五次方数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/322/"},{"categories":["C/C++"],"content":"题目描述 编写程序实现“剪刀，石头，布”游戏。在这个游戏中，两个人同时说“剪刀”，“石头”或“布”，压过另一方的为胜者。规则是：“布”胜过“石头”，“石头”胜过“剪刀”，“剪刀”胜过“布”。要求：选择结构中使用枚举类型，结果的输出也使用枚举类型表示。 输入： 两个数，范围为{0,1,2}，用空格隔开。0表示石头，1表示布，2表示剪刀。这两个数分别表示两个人所说的物品。 输出： 如果前者赢，输出1。如果后者赢，输出-1。如果是平局，输出0。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a,b; while(scanf(\"%d %d\",\u0026a,\u0026b)!=EOF){ if(a==b){ cout\u003c\u003c\"0\"\u003c\u003cendl; } else if(a==0\u0026\u0026b==2||a==1\u0026\u0026b==0||a==2\u0026\u0026b==1){ cout\u003c\u003c\"1\"\u003c\u003cendl; } else{ cout\u003c\u003c\"-1\"\u003c\u003cendl; } } return 0; }  ","date":"2020-11-09","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/320/:0:0","tags":["acm","C/C++","编程"],"title":"石头剪刀布","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/320/"},{"categories":null,"content":"邮箱联系（推荐） 点击 ","date":"2020-11-07","objectID":"/contact/:0:1","tags":null,"title":"联系我们","uri":"/contact/"},{"categories":null,"content":"QQ联系 点击此处调起QQ消息窗口  您也可以在网页各文章下方评论，我们将不定期回复。 ","date":"2020-11-07","objectID":"/contact/:0:2","tags":null,"title":"联系我们","uri":"/contact/"},{"categories":["C/C++"],"content":"题目描述 输出7\"7和7\"7的倍数，还有包含7的数字例如17，27，37,...,70，71，72，73...\"17，27，37,...,70，71，72，73… 输入 一个整数N\"NN。N≤3000\"N≤3000 输出 从小到大排列的不大于N的与7有关的数字，每行一个。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,i=1; cin\u003e\u003en; while(i\u003c=n){ if(i/10==7||i%7==0||i%10==7||i/100==7||i%1000==7){ cout\u003c\u003ci\u003c\u003cendl; } i++; } return 0; }  ","date":"2020-11-06","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/308/:0:0","tags":["acm","C/C++","编程"],"title":"敲7","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/308/"},{"categories":["C/C++"],"content":"题目描述 Problems in Computer Science are often classified as belonging to a certain class of problems (e.g., NP, Unsolvable, Recursive). In this problem you will be analyzing a property of an algorithm whose classification is not known for all possible inputs. Consider the following algorithm: 1. input n 2. print n 3. if n = 1 then STOP 4. if n is odd then n 输入 The input will consist of a series of pairs of integers i and j, one pair of integers per line. All integers will be less than 1,000,000 and greater than 0. You should process all pairs of integers and for each pair determine the maximum cycle length over all integers between and including i and j. You can assume that no opperation overflows a 32-bit integer. 输出 For each pair of input integers i and j you should output i, j, and the maximum cycle length for integers between and including i and j. These three numbers should be separated by at least one space with all three numbers on one line and with one line of output for each line of input. The integers i and j must appear in the output in the same order in which they appeared in the input and should be followed by the maximum cycle length (on the same line). 中文大意：输入多组i,j，分别计算i~j之间的所有数字运算3n+1所需要的步骤次数，输出最大的次数 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int i,j,n=1,z=0,x,ii; //n存储每轮次数，z比较最大次数，x用于计算单次3n+1循环 while(scanf(\"%d %d\",\u0026i,\u0026j)!=EOF) { ii=i; //ii存储i的初始值 while(i\u003c=j) { x=i; while(x!=1) { if(x%2==0) { x=x/2; n++; } else { x=x*3+1; n++; } } if(n\u003ez){ z=n; } n=1; i=i+1; } cout\u003c\u003cii\u003c\u003c\" \"\u003c\u003cj\u003c\u003c\" \"\u003c\u003cz\u003c\u003cendl; z=0; } return 0; }  ","date":"2020-11-06","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/306/:0:0","tags":["acm","C/C++","编程"],"title":"The 3n+1 Problem","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/306/"},{"categories":["C/C++"],"content":"题目描述 计算pi/4=1-1/3+1/5-1/7+….+1/n， 输入 n 输出 根据该算式计算的pi的值（精确6位有效数字） #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ double pi=0,i,n; while(scanf(\"%lf\",\u0026n)!=EOF){ i=3; while(i\u003c=n){ pi=pi+(1/i); i=i+4; } i=5; while(i\u003c=n){ pi=pi-(1/i); i=i+4; } printf(\"%lf\\n\",(1-pi)*4); pi=0; } return 0; }  ","date":"2020-11-06","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/303/:0:0","tags":["acm","C/C++","编程"],"title":"近似计算PI","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/303/"},{"categories":["C/C++"],"content":"题目描述 Hey, welcome to ahstu oj. In this problem, your task is to calculate SUM(n) = 1 + 2 + 3 + … + n. 输入 The input will consist of a series of integers n, one integer per line. 输出 For each case, output SUM(n) in one line. You may assume the result will be in the range of 32-bit signed integer. #include\u003cbits/stdc++.h\u003e int main(){ int n; while(scanf(\"%d\",\u0026n)!=EOF){cout\u003c\u003c(1+n)*n/2\u003c\u003cendl;} return 0; }  ","date":"2020-11-06","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/300/:0:0","tags":["acm","C/C++","编程"],"title":"The Sum Problem数列求和（代码简化）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/300/"},{"categories":["C/C++"],"content":"题目描述 在售货员向顾客找零钱时，一般都是尽可能找最少数量的钱币给顾客。下面将给出一定数额的人民币，请将其分解为数量最少的货币。货币单位仅有100 50 20 10 5 2 1几个币种。 输入 一个整数，即人民币总额（单位元) 输出 分解后的人民币序列，用回车分隔 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; cin\u003e\u003en; while(n\u003e0){ if(n\u003e=100){ cout\u003c\u003c\"100\"\u003c\u003cendl; n=n-100; continue; } if(n\u003e=50){ cout\u003c\u003c\"50\"\u003c\u003cendl; n=n-50; continue; } if(n\u003e=20){ cout\u003c\u003c\"20\"\u003c\u003cendl; n=n-20; continue; } if(n\u003e=10){ cout\u003c\u003c\"10\"\u003c\u003cendl; n=n-10; continue; } if(n\u003e=5){ cout\u003c\u003c\"5\"\u003c\u003cendl; n=n-5; continue; } if(n\u003e=2){ cout\u003c\u003c\"2\"\u003c\u003cendl; n=n-2; continue; } if(n\u003e=1){ cout\u003c\u003c\"1\"\u003c\u003cendl; n=n-1; continue; } } return 0; }  ","date":"2020-11-06","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/297/:0:0","tags":["acm","C/C++","编程"],"title":"找零钱","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/297/"},{"categories":["C/C++"],"content":"题目描述 墙角堆着一些小木块，每一层都有相同大小类似正方体，如下图所示： 因为小木块建造得实在是太有规律了，你只要知道它的层数就可以计算所有小木块的数量了。 现在请你写个程序 给你一个层数m\"mm，求出这个所有小木块的数量。 输入 第一行是一个整数N(N≤10)\"N(N≤10)表示测试数据的组, 接下来的N\"N行 每行只有一个整数m\"m ，表示这个层数。 输出 对应每个输入的层数有一个输出，表示这个小木块总数量，每个输出占一行 #include\u003cstdio.h\u003e int a(int n){ n = (1+n)*n/2; return n; } int main(){ int n; scanf(\"%d\", \u0026n); for (int i = n; i\u003e=1; --i){ int m, sum=0; scanf(\"%d\", \u0026m); for (int b = m; b\u003e=1; --b){ sum += a(b); } printf(\"%d\\n\", sum); } }  ","date":"2020-11-05","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/258/:0:0","tags":["acm","C/C++","编程"],"title":"数数小木块","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/258/"},{"categories":["C/C++"],"content":"题目描述 输出所有形如aabb\"aabb的四位完全平方数，每一个一行 输入 无 输出 输出所有形如aabb\"aabb的四位完全平方数，每一个一行 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a=1000; while(a\u003c10000) { for(int i=33;i*i\u003c=a;i++) { if(i*i==a) if(a%10==a/10%10\u0026\u0026a/100%10==a/1000) cout\u003c\u003ca\u003c\u003cendl; } a++; } return 0; }   ","date":"2020-11-05","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/255/:0:0","tags":["acm","C/C++","编程"],"title":"aabb问题","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/255/"},{"categories":["C/C++"],"content":"题目描述 角谷猜想: 日本一位中学生发现一个奇妙的“定理”，请角谷教授证明，而教授无能为力，于是产生角谷猜想。猜想的内容是：任给一个自然数，若为偶数除以2，若为奇数则乘3加1，得到一个新的自然数后按照上面的法则继续演算，若干次后得到的结果必然为1。请编程验证。 输入 任一正整数 n 范围[2,1000000] 输出 演算的过程 #include \u003cstdio.h\u003e main() { long long n; scanf(\"%lld\",\u0026n); while(n!=1) { if(n%2==0) { printf(\"%lld/2=%lld\\n\",n,n/2); n/=2; } else { printf(\"%lld*3+1=%lld\\n\",n,n*3+1); n=n*3+1; } } }   ","date":"2020-11-05","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/250/:0:0","tags":["acm","C/C++","编程"],"title":"角谷猜想","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/250/"},{"categories":["C/C++"],"content":"题目描述 Print a Frame Draw a frame which has a height of H cm and a width of W cm. For example, the following figure shows a frame which has a height of 6 cm and a width of 10 cm. ########## #........# #........# #........# #........# ########## 输入 The input consists of multiple datasets. Each dataset consists of two integers H and W separated by a single space. The input ends with two 0 (when both H and W are zero). 输出 For each dataset, print the frame made of ‘#’ and ‘.’. Print a blank line after each dataset. #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a,b; while(scanf(\"%d %d\",\u0026a,\u0026b)!=EOF) { if(a==0\u0026\u0026b==0) break; for(int i=1;i\u003c=a;i++) { if(i==1||i==a) { for(int j=0;j\u003cb;j++) { cout\u003c\u003c\"#\"; } cout\u003c\u003cendl; } else { for(int j=1;j\u003c=b;j++) { if(j==1||j==b) cout\u003c\u003c\"#\"; else cout\u003c\u003c\".\"; } cout\u003c\u003cendl; } } cout\u003c\u003cendl; } return 0; }  ","date":"2020-11-05","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/288/:0:0","tags":["acm","C/C++","编程"],"title":"Structured Program I – Print a Frame","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/288/"},{"categories":["C/C++"],"content":"题目描述 定义$N$的双阶乘: N!!=N∗(N−2)∗(N−4)∗....i\"N!!=N∗(N−2)∗(N−4)∗....i（$i=1or\"ori=2$） 比如5!!=5∗3∗1=15\"5!!=5∗3∗1=15 而6!!=6∗4∗2=48\"6!!=6∗4∗2=48 特别的我们定义0!!=1!!=1\"!!=1!!=1 给定N\"NN你的任务是计算出N!!\"N!!N!!(你可以假设答案不超过int 范围） 输入 多组输入，每行一个整数N\"NN 输出 你的任务是计算出N!!\"N!!N!!(你可以假设答案不超过int 范围） 注：需要分奇偶分别计算 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,s,x; while(scanf(\"%d\",\u0026n)!=EOF){ s=n; if(n%2==0){ while(n\u003e2){ x=n-2; s=s*x; n=x; } cout\u003c\u003cs\u003c\u003cendl;} else{ while(n\u003e1){ x=n-2; s=s*x; n=x; } cout\u003c\u003cs\u003c\u003cendl;} } return 0; }  ","date":"2020-11-05","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/276/:0:0","tags":["acm","C/C++","编程"],"title":"计算双阶乘","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/276/"},{"categories":["C/C++"],"content":"题目描述 已知鸡和兔的总数量为n,总腿数为m。输入n和m,依次输出鸡和兔的数目，如果无解，则输出“No answer”(不要引号)。 输入 第一行输入一个数据a,代表接下来共有几组数据，在接下来的(a输出 输出鸡兔的个数，或者No answer #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a,n,m,x,y; cin\u003e\u003ea; while(a--){ cin\u003e\u003en\u003e\u003em; if(m%2==0){ y=(m-2*n)/2; //tu x=n-y; //ji if(x\u003e=0\u0026\u0026y\u003e=0){ cout\u003c\u003cx\u003c\u003c\" \"\u003c\u003cy\u003c\u003cendl; } else{ cout\u003c\u003c\"No answer\"\u003c\u003cendl; } } else{ cout\u003c\u003c\"No answer\"\u003c\u003cendl; } } return 0; }  ","date":"2020-11-05","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/270/:0:0","tags":["acm","C/C++","编程"],"title":"鸡兔同笼","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/270/"},{"categories":["C/C++"],"content":"题目描述 Print a Rectangle Draw a rectangle which has a height of H cm and a width of W cm. Draw a 1-cm square by single ‘#’. 输入 The input consists of multiple datasets. Each dataset consists of two integers H and W separated by a single space. The input ends with two 0 (when both H and W are zero). 输出 For each dataset, print the rectangle made of H × W ‘#’. Print a blank line after each dataset. #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int h,w,i,j; while(scanf(\"%d %d\",\u0026h,\u0026w)!=EOF) { if(h==0\u0026\u0026w==0){ return 0; } else { for(i=0;i\u003ch;i=i+1){ for(j=0;j\u003cw;j=j+1){ cout\u003c\u003c\"#\"; } cout\u003c\u003cendl; } printf(\"\\n\");} } }  ","date":"2020-11-05","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/268/:0:0","tags":["acm","C/C++","编程"],"title":"Structured Program I – Print a Rectangle","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/268/"},{"categories":["C/C++"],"content":"题目描述 打印如下的三角形（n=3） * ** *** 输入 三角形的层数n 输出 打印好的三角形 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,i,j; cin\u003e\u003en; for(i=0;i\u003cn;i++) { for(j=0;j\u003c=i;j++) printf(\"*\"); printf(\"\\n\"); } printf(\"\\n\"); return 0; }  ","date":"2020-11-04","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/264/:0:0","tags":["acm","C/C++","编程"],"title":"打印星星三角形","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/264/"},{"categories":["C/C++"],"content":"题目描述 写一个函数，求两个整数的最大公约数。通过主函数调用这个函数，并输出结果。 两个整数通过键盘输入。 输入 空格分隔的2个整数 输出 输入两数的最大公约数，单独占一行。 #define _CRT_SECURE_NO_WARNINGS #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a, b, i=1, t=0; cin \u003e\u003e a \u003e\u003e b; while (i \u003c= a || i \u003c= b) { if (a % i == 0 \u0026\u0026 b % i == 0) { t = i; } i++; } cout \u003c\u003c t \u003c\u003c endl; return 0; }  ","date":"2020-11-04","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/262/:0:0","tags":["acm","C/C++","编程"],"title":"最大公约数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/262/"},{"categories":["C/C++"],"content":"题目描述 猜想：对于任意大于1的自然数n\"n,如果n\"n为奇数，则n=3n+1\"n=3n+1n=3n+1,否则n=n/2\"n=n/2,则经过若干步骤后n\"n一定会变成1\"1； 如：3−\u003e10−\u003e5−\u003e16−\u003e8−\u003e4−\u003e2−\u003e1\"3−10−5−16−8−4−2−1 共7\"7步， 输入n\"n, 输出变换次数 输入 多组输入，每行有一个n\"n, 1≤n≤109\"1≤n≤109 输出 变换次数 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n2; while(cin\u003e\u003en2) { long long n=n2; //避免了对long long 的输入输出 int t=0; while(n!=1) { if(n%2==1) n=3*n+1; else n=n/2; t++; } cout\u003c\u003ct\u003c\u003cendl; } return 0; }  ","date":"2020-10-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/286/:0:0","tags":["acm","C/C++","编程"],"title":"3n+1","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/286/"},{"categories":["C/C++"],"content":"题目描述 给出等腰梯形的上底、下底和高，要求计算该梯形的面积与周长。 输入 输入数据只有一行，每行依次出现三个数U、D、H，分别表示等腰梯形的上底、下底和高。（ 0 输出 输出两行，第一行输出梯形的面积，第二行输出梯形的周长。（面积和周长均保留2位小数） #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ double u,d,h,s,c,t; cin\u003e\u003eu\u003e\u003ed\u003e\u003eh; t=sqrt(h*h+(((d-u)/2)*((d-u)/2))); s=(u+d)*h/2; c=u+d+2*t; printf(\"%.2lf\\n%.2lf\",s,c); return 0; }  ","date":"2020-10-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/284/:0:0","tags":["acm","C/C++","编程"],"title":"梯形","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/284/"},{"categories":["C/C++"],"content":"题目描述 小时候唐巧住在农村老家，老家的山很高，每次无聊的时候，他都会对着山大声说话，这个时候，山也会对他“说”同样的话（回声）。现在唐巧虽然已经长大了，但是还是常常想起儿时的故事，他想：如果可以再体会一下儿时的那种感觉多好呀! 请你编程完成模拟回声的程序。 输入 输入数据有多行，每行为一个字符串（字符串只由字母组成），字符串最长为15。以EOF结束。 输出 对于每行输入，输出同样的内容。 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { char a[15]; while (scanf(\"%s\",\u0026a)!=EOF) { printf(\"%s\\n\",a); } return 0; }  ","date":"2020-10-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/282/:0:0","tags":["acm","C/C++","编程"],"title":"输入输出（字符串）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/282/"},{"categories":["C/C++"],"content":"题目描述 正整数的各位数字之和称为Tom数。求输入n\"n, n≤231−1\"n≤231−1的Tom数! 输入 每行一个整数n\"n ,n≤231−1\"n≤231−1. 输出 每行一个输出,对应该数的各位数之和. 方法一 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n; char s[1001]; while(scanf(\"%s\",\u0026s)!=EOF) { int a=0; n=strlen(s); for(int i=0; i\u003cn; i++) { a+=(s[i]-‘0‘); } printf(\"%d\\n\",a); } return 0; }  方法二：优化版 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { char a[11]; while(gets(a)!=NULL){ int i,sum=0; for(i=0;i\u003cstrlen(a);i++) sum+=a[i]-'0'; //将字母转换成数字 printf(\"%d\\n\",sum); } return 0; }  ","date":"2020-10-31","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/274/:0:0","tags":["acm","C/C++","编程"],"title":"Tom数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/274/"},{"categories":["C/C++"],"content":"题目描述 计算从 m 到 n 能同时被3和5整除的数的个数 输入 输入两个整数 m, n ( 0 输出 输出从 m 到 n 能同时被3和5整除的数的个数 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,m,i=0; cin\u003e\u003em\u003e\u003en; while(m\u003c=n){ if(m%3==0\u0026\u0026m%5==0){ i++; } m++; } cout\u003c\u003ci\u003c\u003cendl; return 0; }   ","date":"2020-10-30","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/248/:0:0","tags":["acm","C/C++","编程"],"title":"被3和5整除的数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/248/"},{"categories":["C/C++"],"content":"题目描述 输出以下图案： * *** ***** ******* ***** *** * 输出 输出如题目描述中的图案。 请注意行尾输出换行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ cout\u003c\u003c\" *\\n ***\\n *****\\n*******\\n *****\\n ***\\n *\"\u003c\u003cendl; return 0; }  ","date":"2020-10-30","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/238/:0:0","tags":["acm","C/C++","编程"],"title":"输出菱形","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/238/"},{"categories":["C/C++"],"content":"题目描述 输入一个大于等于3的正整数，判断其是否是素数。 输入 一个大于等于3并小于10000的正整数n，判断n是否是素数。 输出 如果n是素数，输出“prime”，否则请输出“not prime”。 请注意不需要输出引号，行尾输出换行。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,a=0; scanf(\"%d\",\u0026n); for(int i=1;n\u003ei;i++){ if(n%i==0){ a++; } } if(a==1){ cout\u003c\u003c\"prime\"\u003c\u003cendl; } else{ cout\u003c\u003c\"not prime\"\u003c\u003cendl; } return 0; }  ","date":"2020-10-30","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/234/:0:0","tags":["acm","C/C++","编程"],"title":"判断素数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/234/"},{"categories":["C/C++"],"content":"题目描述 输入正整数n 输出H（n）=1+1/2+1/3+….+1/n的值，保留3位有效数字 输入 输入正整数n (n 输出 输出H（n）=1+1/2+1/3+….+1/n的值，保留3位有效数字 #define _CRT_SECURE_NO_WARNINGS\r#include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main()\r{\rint n, i = 1;\rlong double h = 0,x,y;\rwhile (scanf(\"%d\", \u0026n) != EOF) {\rwhile (i \u003c= n) {\rlong double ii = (int)i; //将整形i转换为浮点型ii\rh = h +(1/ii); //不同类型数据之间不能计算！\ri = i + 1;\r}\rprintf(\"%.3Lf\\n\", h);\rh = 0; i = 1;\r}\rreturn 0;\r}  ","date":"2020-10-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/158/:0:0","tags":["acm","C/C++","编程"],"title":"调和级数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/158/"},{"categories":["C/C++"],"content":"题目描述 Circle Write a program which calculates the area and circumference of a circle for given radius r. 输入 A real number r is given. 输出 Print the area and circumference of the circle in a line. Put a single space between them. The output should not contain an absolute error greater than 10^-5. #include\u003cbits/stdc++.h\u003e\r#define pi 3.14159265358979323846264338327950288419716939937510\rusing namespace std;\rint main(){\rlong double r,s,c;\rscanf(\"%Lf\",\u0026r);\rc=2*pi*r;\rs=pi*r*r;\rprintf(\"%Lf %Lf\",s,c);\rreturn 0;\r}  ","date":"2020-10-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/156/:0:0","tags":["acm","C/C++","编程"],"title":"Circle","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/156/"},{"categories":["C/C++"],"content":"题目描述 输出区间[a,b]中的所有水仙花数，若三位数ABC满足ABC=A^3+B^3+C^3,则称为水仙花数。例如153=1^3+5^3+3^3，所以 153是水仙花数 输入 一个区间【a,b】,b,a都是非负整数 且满足b＞ａ＞０ 输出 输出区间[a,b】中的所有水仙花数（每一个１行） #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a,b,c,x,y; cin\u003e\u003ex\u003e\u003ey; while(x\u003cy){ a = x % 10; b = ((x % 100) - a) / 10; c = (((x % 1000) - a) - 10 * b) / 100; if (x == (a * a * a) + (b * b * b) + (c * c * c)){ cout\u003c\u003cx\u003c\u003cendl; } x=x+1;a=0;b=0;c=0; } return 0; }  ","date":"2020-10-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/144/:0:0","tags":["acm","C/C++","编程"],"title":"水仙花问题（4）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/144/"},{"categories":["C/C++"],"content":"算法一：求从后往前每次增加蟠桃数的通项公式，再累加 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n,i=1,s=3,t=1;\rwhile(scanf(\"%d\",\u0026n)!=EOF){\rwhile(n\u003ei){\ri=i+1;\rt=t+s;\rs=2*s;\r}\rcout\u003c\u003ct\u003c\u003cendl;\ri=1;s=3;t=1;\r}\rreturn 0;\r}  ","date":"2020-10-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/140/:0:0","tags":["acm","C/C++","编程"],"title":"蟠桃记","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/140/"},{"categories":["C/C++"],"content":"题目描述 给定m\"m根据以下公式计算T(m)\"T(m)： T(m)=1-(1/(2*2))-….-(1/(m*m)) \u003ch2 class=\"page-header text-muted\"\u003e 输入 \u003c/h2\u003e \u003cdiv class=\"content\"\u003e \u003cp\u003e 整型变量m范围[2,1000] \u003c/p\u003e \u003c/div\u003e \u003ch2 class=\"page-header text-muted\"\u003e 输出 \u003c/h2\u003e \u003cdiv class=\"content\"\u003e \u003cp\u003e 计算\u003cspan id=\"MathJax-Element-11-Frame\" class=\"MathJax\" style=\"box-sizing: border-box; font-size: 15px; display: inline; font-style: normal; font-weight: normal; line-height: normal; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;\" tabindex=\"0\" role=\"presentation\" data-mathml=\"\u003cmath xmlns=\u0026quot;http://www.w3.org/1998/Math/MathML\u0026quot;\u003e\u003cmi\u003eT\u003c/mi\u003e\u003cmo stretchy=\u0026quot;false\u0026quot;\u003e(\u003c/mo\u003e\u003cmi\u003em\u003c/mi\u003e\u003cmo stretchy=\u0026quot;false\u0026quot;\u003e)\u003c/mo\u003e\u003c/math\u003e\"\u003e\u003cspan id=\"MathJax-Span-89\" class=\"math\"\u003e\u003cspan id=\"MathJax-Span-90\" class=\"mrow\"\u003e\u003cspan id=\"MathJax-Span-91\" class=\"mi\"\u003eT\u003c/span\u003e\u003cspan id=\"MathJax-Span-92\" class=\"mo\"\u003e(\u003c/span\u003e\u003cspan id=\"MathJax-Span-93\" class=\"mi\"\u003em\u003c/span\u003e\u003cspan id=\"MathJax-Span-94\" class=\"mo\"\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e(保留六位小数) \u003c/p\u003e \u003c/div\u003e #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint m,i=1;\rlong double t,x,y;\rt=1;\rcin\u003e\u003em;\rwhile(i\u003cm){\ri=i+1;\rx=i*i;\ry=1/x;\rt=t-y;\r}\rprintf(\"%.6Lf\",t);\rreturn 0;\r}  ","date":"2020-10-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/138/:0:0","tags":["acm","C/C++","编程"],"title":"求T(m)的值","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/138/"},{"categories":["C/C++"],"content":"题目描述 一个球从100\"100米高度自由落下,每次落地后反跳回原来高度的一半,再落下,再反弹.求它在第N\"N次落地时共经过多少米? 输入 反弹的次数N范围[2,1000] 输出 小球经过的路程(保留四位小数) #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; double s=100,x=100; cin\u003e\u003en; for(;n\u003e1;n=n-1){ x=x/2; s=s+2*x; } printf(\"%.4lf\",s); return 0; }    ","date":"2020-10-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/136/:0:0","tags":["acm","C/C++","编程"],"title":"自由落体问题","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/136/"},{"categories":["C/C++"],"content":"题目描述 Simple Calculator Write a program which reads two integers a, b and an operator op, and then prints the value of a op b. The operator op is ‘+’, ‘-‘, ‘*’ or ‘/’ (sum, difference, product or quotient). The division should truncate any fractional part. 输入 The input consists of multiple datasets. Each dataset is given in the following format. a op b The input ends with a single ‘?’. Your program should not process for this terminal symbol. 输出 For each dataset, print the value in a line. 重点就在于比较符号是否相等 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint a,b,z,s;\rwhile(scanf(\"%d %c %d\",\u0026a,\u0026z,\u0026b)!=EOF){\rif (z=='+'){\rs=a+b;\r}\rif (z=='-'){\rs=a-b;\r}\rif (z=='*'){\rs=a*b;\r}\rif (z=='/'){\rs=a/b;\r}\rif (z=='?'){\rreturn 0;\r}\rcout\u003c\u003cs\u003c\u003cendl;\rs=0;\r}\r}  ","date":"2020-10-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/176/:0:0","tags":["acm","C/C++","编程"],"title":"Simple Calculator","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/176/"},{"categories":["C/C++"],"content":"题目描述 给定两个整数n m, 0 输入 有多组测试数据，每一行有n m 输出 1/n^2+1/(n+1)^2+….+1/m^2保留5位小数 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rint n,m;\rlong double s=0;\rwhile(scanf(\"%d %d\",\u0026n,\u0026m)!=EOF){\rwhile(n\u003c=m){\rlong double nn=(int)n;\rs=s+(1/(nn*nn));\rn=n+1;\r}\rprintf(\"%.5Lf\\n\",s);\rs=0;\r}\rreturn 0;\r}  ","date":"2020-10-28","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/169/:0:0","tags":["acm","C/C++","编程"],"title":"子序列之和","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/169/"},{"categories":["C/C++"],"content":"题目描述 A/B Problem Write a program which reads two integers a and b, and calculates the following values: a ÷ b: d (in integer) remainder of a ÷ b: r (in integer) a ÷ b: f (in real number) 输入 Two integers a and b are given in a line. 输出 Print d, r and f separated by a space in a line. For f, the output should not contain an absolute error greater than 10^-5. 注：此题为特殊判断机制（special judge），精确到小数点后6位（long double默认精确度）即可。 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\rint main(){\rlong double a,b;\rscanf(\"%Lf %Lf\",\u0026a,\u0026b);\rint c=(int)a;\rint d=(int)b;\rprintf(\"%d %d %Lf\",c/d,c%d,a/b);\rreturn 0;\r}  ","date":"2020-10-27","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/152/:0:0","tags":["acm","C/C++","编程"],"title":"A / B Problem","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/152/"},{"categories":["C/C++"],"content":"题目描述 相传韩信才智过人，从不直接清点自己的军队的个数，只要让士兵先后以三人一排，五人一排，七人一排，变换队形，而他每次只掠一眼队伍的排尾人数就知道总人数了，输入三个非负整数,a,b,c表示每种队形排尾的人数，(a 输入 ，输入三个非负整数,a,b,c表示每种队形排尾的人数，(a 输出 输出总人数的最小值（或报告无解） 注：需使用中国剩余定理 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a,b,c,t; while(scanf(\"%d %d %d\",\u0026a,\u0026b,\u0026c)!=EOF){ t=a*70+21*b+c*15; while(t\u003e105){ t=t-105; } if(t\u003e100){ cout\u003c\u003c\"No answer\"\u003c\u003cendl; } else{ cout\u003c\u003ct\u003c\u003cendl; } t=0; } return 0; }  ","date":"2020-10-27","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/167/:0:0","tags":["acm","C/C++","编程"],"title":"韩信点兵","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/167/"},{"categories":["C/C++"],"content":"题目描述 Your task is to calculate the sum of some integers. 输入 Input contains an integer N in the first line, and then N lines follow. Each line starts with a integer M, and then M integers follow in the same line. 输出 For each group of input integers you should output their sum in one line, and with one line of output for each line in input. #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,sum=0,a; while(scanf(\"%d\",\u0026n)!=EOF){ while(n\u003e0){ scanf(\"%d\",\u0026a); n=n-1; sum=sum+a; } cout\u003c\u003csum\u003c\u003cendl; sum=0; } return 0; }  ","date":"2020-10-27","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/185/:0:0","tags":["acm","C/C++","编程"],"title":"A+B","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/185/"},{"categories":["C/C++"],"content":"题目描述 Min, Max and Sum Write a program which reads a sequence of n integers ai(i=1,2,…n), and prints the minimum value, maximum value and sum of the sequence. 输入 In the first line, an integer n is given. In the next line, n integers ai are given in a line. 输出 Print the minimum value, maximum value and sum in a line. Put a single space between the values. 注：还应该比较max或min与新赋值i的大小 #define _CRT_SECURE_NO_WARNINGS #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a, n, i, max, min, sum, t; scanf(\"%d %d\", \u0026n, \u0026a); sum = a; max = a; min = a; while (n \u003e 1) { scanf(\"%d\", \u0026i); sum = sum + i; if (a \u003c= i) { if (max \u003c i) { max = i; } if (min \u003e a) { min = a; } } else { if (max \u003c a) { max = a; } if (min \u003e i) { min = i; } } n = n - 1; } cout \u003c\u003c min \u003c\u003c \" \" \u003c\u003c max \u003c\u003c \" \" \u003c\u003c sum \u003c\u003c endl; return 0; }     ","date":"2020-10-27","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/179/:0:0","tags":["acm","C/C++","编程"],"title":"Computation – Min, Max and Sum","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/179/"},{"categories":["C/C++"],"content":"题目描述 小明今年3岁了, 现在他已经能够认识100以内的非负整数, 并且能够进行100以内的非负整数的加法计算. 对于大于等于100的整数, 小明仅保留该数的最后两位进行计算, 如果计算结果大于等于100, 那么小明也仅保留计算结果的最后两位. 例如, 对于小明来说: 1) 1234和34是相等的 2) 35+80=15 给定非负整数A和B, 你的任务是代表小明计算出A+B的值. 输入 输入数据的第一行为一个正整数T, 表示测试数据的组数. 然后是T组测试数据. 每组测试数据包含两个非负整数A和B(A和B均在int型可表示的范围内). 输出 对于每组测试数据, 输出小明A+B的结果. #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a,b,t,s; cin\u003e\u003et; while(scanf(\"%d %d\",\u0026a,\u0026b)!=EOF){ s=a+b; s=s%100; cout\u003c\u003cs\u003c\u003cendl; } return 0; }  ","date":"2020-10-25","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/188/:0:0","tags":["acm","C/C++","编程"],"title":"小明A+B","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/188/"},{"categories":["C/C++"],"content":"题目描述 设圆半径r\"r，圆柱高h\"h 求圆周长C1=2πr\"C1、圆面积Sa、圆球表面积Sb=4πr2\"Sb、圆球体积Va=4πr33\"Va、圆柱体积Vb=πr2h\"Vb。 用scanf输入数据，输出计算结果，输出时要求文字说明，取小数点后两位数字。请编程序。 π＝3.141592653\"π＝3.141592653 输入 两个浮点数，r\"r和h\"h 输出 圆周长C1\"C1、圆面积Sa\"Sa、圆球表面积Sb\"Sb、圆球体积Va\"Va、圆柱体积Vb\"Vb。 保留两位小数，每个结果后换行。 #include\u003cbits/stdc++.h\u003e\rusing namespace std;\r#define pi 3.141592653\rint main() {\rdouble r, h;\rdouble C1, Sa, Sb, Va, Vb;\rscanf(\"%lf %lf\", \u0026r, \u0026h);\rC1 = 2 * pi * r;\rSa = pi * r * r;\rSb = 4 * pi * r * r;\rVa = (4 * pi * r * r * r) / 3;\rVb = pi * r * r * h;\rprintf(\"C1=%.2lf\\n\", C1);\rprintf(\"Sa=%.2lf\\n\", Sa);\rprintf(\"Sb=%.2lf\\n\", Sb);\rprintf(\"Va=%.2lf\\n\", Va);\rprintf(\"Vb=%.2lf\\n\", Vb);\rreturn 0;\r}  ","date":"2020-10-19","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/126/:0:0","tags":["acm","C/C++","编程"],"title":"立体几何求解","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/126/"},{"categories":["C/C++"],"content":"输出以下信息： Very Good! 数＊号可看出，Very前面9空格，Good前面…… *也是输出的一部分，别光打印Very Good! #define _CRT_SECURE_NO_WARNINGS #include\u003cbits/stdc++.h\u003e using namespace std; int main() { cout\u003c\u003c\"**************************\\n\"\u003c\u003c\" \"\u003c\u003c\"Very\"\u003c\u003c\" \"\u003c\u003c\"Good!\\n\"\u003c\u003c\"**************************\"\u003c\u003cendl; return 0; } ","date":"2020-10-19","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/124/:0:0","tags":["acm","C/C++","编程"],"title":"打印文字","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/124/"},{"categories":["C/C++"],"content":"判断多组数据是否为水仙花数 算法：使用while多次读取数值，并计算是否为水仙花数 #define _CRT_SECURE_NO_WARNINGS\r#include\u003cbits/stdc++.h\u003e\rint main() {\rint x, a, b, c;\rwhile (scanf(\"%d\", \u0026x) != EOF) {\rif (x == 0) {\rreturn 0;\r}\ra = x % 10;\rb = ((x % 100) - a) / 10;\rc = (((x % 1000) - a) - 10 * b) / 100;\rif (x == (a * a * a) + (b * b * b) + (c * c * c)) {\rprintf(\"Yes\\n\");\r}\relse {\rprintf(\"No\\n\");\r}\r}\r}  ","date":"2020-10-19","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/120/:0:0","tags":["acm","C/C++","编程"],"title":"水仙花问题（3）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/120/"},{"categories":["C/C++"],"content":"算法：和三位数排序相同，在三位数的基础上多一个与数字d的比较 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a, b, c, d; int x; scanf(\"%d %d %d %d\", \u0026a, \u0026b, \u0026c, \u0026d); if (a \u003c b) { x = a; a = b; b = x; } if (a \u003c c) { x = a; a = c; c = x; } if (a \u003c d) { x = a; a = d; d = x; } if (b \u003c c) { x = b; b = c; c = x; } if (b \u003c d) { x = b; b = d; d = x; } if (c \u003c d) { x = c; c = d; d = x; } printf(\"%d %d %d %d\", d, c, b, a); return 0; } 数组法 c++中有求最大值函数 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int a[4],i; for(i=0;i\u003c4;i++){ cin\u003e\u003ea[i]; } cout\u003c\u003c(*max_element(a, a+ 4)); }  ","date":"2020-10-19","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/117/:0:0","tags":["acm","C/C++","编程"],"title":"四位数排序","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/117/"},{"categories":["C/C++"],"content":"解法一：只使用if语句 #include\u003cbits/stdc++.h\u003e using namespace std; int main(void) { int a; while (scanf(\"%d\", \u0026a) != EOF) { if (a \u003e= 90 \u0026\u0026 a \u003c= 100) { cout \u003c\u003c \"A\" \u003c\u003c endl; } else if (a \u003e= 80 \u0026\u0026 a \u003c= 89) { cout \u003c\u003c \"B\" \u003c\u003c endl; } else if (a \u003e= 70 \u0026\u0026 a \u003c= 79) { cout \u003c\u003c \"C\" \u003c\u003c endl; } else if (a \u003e= 60 \u0026\u0026 a \u003c= 69) { cout \u003c\u003c \"D\" \u003c\u003c endl; } else if (a \u003e= 0 \u0026\u0026 a \u003c= 59) { cout \u003c\u003c \"E\" \u003c\u003c endl; } else { cout \u003c\u003c \"Score is error!\" \u003c\u003c endl; } } return 0; } 解法二：使用switch语句 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n; char s; while(scanf(\"%d\",\u0026n)!=EOF){ if(n\u003e=80){s='a';} if(n\u003e=70\u0026\u0026n\u003c=79){s='b';} if(n\u003e=60\u0026\u0026n\u003c=69){s='c';} if(n\u003c60\u0026\u0026n\u003e=0){s='d';} if(n\u003c0||n\u003e100){s='e';} switch(s){ case 'a' : printf(\"A\\n\");break; case 'b' : printf(\"B\\n\");break; case 'c' : printf(\"C\\n\");break; case 'd' : printf(\"D\\n\");break; case 'e' : printf(\"E\\n\");break; default : printf(\"Score is error\\n\");break; } } return 0; }  ","date":"2020-10-19","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/114/:0:0","tags":["acm","C/C++","编程"],"title":"成绩转换","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/114/"},{"categories":["C/C++"],"content":"给定秒数计算小时分钟（时间转换） ","date":"2020-10-18","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/91/:0:0","tags":["acm","C/C++","编程"],"title":"给定秒数计算小时分钟（时间转换）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/91/"},{"categories":["C/C++"],"content":"题目描述 给定一个以秒为单位的时间t，要求用 “\u003c H\u003e :\u003c M\u003e :\u003c S\u003e ”的格式来表示这个时间。\u003c H\u003e 表示时间，\u003c M\u003e 表示分钟， 而\u003c S\u003e 表示秒，它们都是整数且没有前导的“0”。例如，若t=0，则应输出是“0:0:0”；若t=3661，则输出“1:1:1”。 ","date":"2020-10-18","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/91/:1:0","tags":["acm","C/C++","编程"],"title":"给定秒数计算小时分钟（时间转换）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/91/"},{"categories":["C/C++"],"content":"输入 输入只有一行，是一个整数t（0\u003c =t\u003c =86399）。 ","date":"2020-10-18","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/91/:2:0","tags":["acm","C/C++","编程"],"title":"给定秒数计算小时分钟（时间转换）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/91/"},{"categories":["C/C++"],"content":"输出 输出只有一行，是以“\u003c H\u003e :\u003c M\u003e :\u003c S\u003e ”的格式所表示的时间，不包括引号。 #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ int h, m,s,x; scanf(\"%d\",\u0026x); h=x/3600; m=(x-(h*3600))/60; s=(x-(h*3600)-m*60); cout\u003e\u003eh\u003e\u003e\":\"\u003e\u003em\u003e\u003e\":\"\u003e\u003es; return 0; } ","date":"2020-10-18","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/91/:3:0","tags":["acm","C/C++","编程"],"title":"给定秒数计算小时分钟（时间转换）","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/91/"},{"categories":["C/C++"],"content":"使用最简单的if语句实现给定年月判断天数 #include\u003cbits/stdc++.h\u003eusing namespace std; int main() { int y, m, d; cin \u0026gt;\u0026gt; y \u0026gt;\u0026gt; m; if (y % 4 == 0 \u0026\u0026 y % 100 != 0 || y % 100 == 0 \u0026\u0026 y % 400 == 0) { if (m == 1 || m == 3) { d = 31; } if (m == 5 || m == 7) { d = 31; } if (m == 8 || m == 10) { d = 31; } if (m == 12) { d = 31; } if (m == 4 || m == 6) { d = 30; } if (m == 9 || m == 11) { d = 30; } if (m == 2) { d = 29; } } else { if (m == 1 || m == 3) { d = 31; } if (m == 5 || m == 7) { d = 31; } if (m == 8 || m == 10) { d = 31; } if (m == 12) { d = 31; } if (m == 4 || m == 6) { d = 30; } if (m == 9 || m == 11) { d = 30; } if (m == 2) { d = 28; } } cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; return 0; } ","date":"2020-10-17","objectID":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/67/:0:0","tags":["acm","C/C++","编程"],"title":"通过年月判断天数","uri":"/2020/%E7%BC%96%E7%A8%8B/c-cpp/67/"},{"categories":null,"content":" 感谢您信赖HZK’s Blog。您的隐私对于我们至关重要，我们希望为您提供安全可靠的在线体验。本隐私政策阐明了我们如何收集和使用您的信息，以及您就我们如何使用您的信息所拥有的选择。 本隐私政策适用于zekun.fun以及其下所设所有子域名： www.zekun.fun以及其他zekun.fun拥有和/或运作的包含指向本隐私政策链接的网站（以下统称为“网站”） ","date":"2020-10-15","objectID":"/privacy-policy/:0:0","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"我们是谁 本站的站点地址是：https://bloglite.zekun.fun。 ","date":"2020-10-15","objectID":"/privacy-policy/:1:0","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"我们收集何种及为何收集个人数据 HZK’s Blog 可能会收集和保存用户自愿情况下所提供的信息，我们可能将从您这里收集的个人信息与从其他服务或从第三方获得的信息进行整合，以向您提供更好的用户服务，包括为您提供定制的在线服务。 当您访问本网站或使用我们的某些在线工具时，服务器会自动记录信息，包括但不限于URL、IP地址、浏览器的类型和使用的语言以及访问日期和时间。 HZK’s Blog 可能会展示第三方的内容或者广告，第三方可在您的浏览器上放置和读取 cookie ，或使用网站信标（web beacon）收集信息。 ","date":"2020-10-15","objectID":"/privacy-policy/:2:0","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"评论 当访客留下评论时，我们会收集评论表单所显示的数据，和访客的IP地址及浏览器的user agent字符串来帮助检查垃圾评论。 由您的电子邮件地址所生成的匿名化字符串（又称为哈希）可能会被提供给Gravatar服务确认您是否有使用该服务。Gravatar服务的隐私政策在此：https://automattic.com/privacy/。在您的评论获批准后，您的资料图片将在您的评论旁公开展示。 ","date":"2020-10-15","objectID":"/privacy-policy/:2:1","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"媒体 如果您向此网站上传图片，您应当避免上传那些有嵌入地理位置信息（EXIF GPS）的图片。此网站的访客将可以下载并提取此网站的图片中的位置信息。 Cookies 如果您在我们的站点上留下评论，您可以选择用cookies保存您的姓名、电子邮件地址和网站。这是通过让您可以不用在评论时再次填写相关内容而向您提供方便。这些cookies会保留一年。 如果您访问我们的登录页，我们会设置一个临时的cookie来确认您的浏览器是否接受cookies。此cookie不包含个人数据，且会在您关闭浏览器时被丢弃。 当您登录时，我们也会设置多个cookies来保存您的登录信息及屏幕显示选项。登录cookies会保留两天，而屏幕显示选项cookies会保留一年。如果您选择了“记住我”，您的登录会保留两周。如果您注销，登录cookies将被移除。 如果您编辑或发布文章，我们会在您的浏览器中保存一个额外的cookie。这个cookie不包含个人数据而只记录了您刚才编辑的文章的ID。这个cookies会保留一天。 ","date":"2020-10-15","objectID":"/privacy-policy/:2:2","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"其他站点的嵌入内容 此站点上的文章可能会包含嵌入的内容（如视频、图像、文章等）。来自其他站点的嵌入内容的行为和您直接访问这些其他站点没有区别。 这些站点可能会收集关于您的数据、使用cookies、嵌入额外的第三方跟踪程序及监视您与这些嵌入内容的交互，包括在您有这些站点的账户并登录了这些站点时，跟踪您与嵌入内容的交互。 ","date":"2020-10-15","objectID":"/privacy-policy/:2:3","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"统计 为方便运营网站，本站使用了多个网站统计程序，用于分析受用户欢迎的文章情况。信息采集属于匿名采集，并且只保留本年度的数据。 ","date":"2020-10-15","objectID":"/privacy-policy/:2:4","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"我们与谁共享您的信息 HZK’s Blog 不会主动透露您的个人信息给任何第三方，网站广告获取的信息仅代表广告运营商的行为，详情请阅读对应广告商的隐私政策。 注：在法律要求下，为配合有效的法律程序，本站将为有关部门提供必要信息。 ","date":"2020-10-15","objectID":"/privacy-policy/:3:0","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"我们保留多久您的信息 如果您留下评论，评论和其元数据将被无限期保存。我们这样做以便能识别并自动批准任何后续评论，而不用将这些后续评论加入待审队列。 对于本网站的注册用户，我们也会保存用户在个人资料中提供的个人信息。所有用户可以在任何时候查看、编辑或删除他们的个人信息（除了不能变更用户名外）、站点管理员也可以查看及编辑那些信息。 ","date":"2020-10-15","objectID":"/privacy-policy/:4:0","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"您对您的信息有什么权利 如果您有此站点的账户，或曾经留下评论，您可以要求我们抹除所有关于您的个人数据。这不包括我们因管理、法规或安全需要而必须保留的数据。 您所使用的浏览器，比如Internet Explorer或者Mozilla Firefox，允许你删除cookie并设置所允许cookie的类别。具体的使用方法，请查询浏览器的帮助。 ","date":"2020-10-15","objectID":"/privacy-policy/:5:0","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"我们将您的信息发送到哪 访客评论可能会被自动垃圾评论监测服务检查。 ","date":"2020-10-15","objectID":"/privacy-policy/:6:0","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"联系我们 请访问Contact Us界面 ","date":"2020-10-15","objectID":"/privacy-policy/:7:0","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"  ","date":"2020-10-15","objectID":"/privacy-policy/:7:1","tags":null,"title":"隐私政策","uri":"/privacy-policy/"},{"categories":null,"content":"我们可能在事先通知或不通知的情况下随时更改此”隐私政策”，或更改、修订或收回访问本网站的权利或网页的内容。 ","date":"2020-10-15","objectID":"/privacy-policy/:7:2","tags":null,"title":"隐私政策","uri":"/privacy-policy/"}]